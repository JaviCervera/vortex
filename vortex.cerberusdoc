# Module vortex

The Vortex module adds an easy to use 3D rendering engine based on OpenGL ES 2.
It is inspired by the design of the Blitz3D engine, but it uses many object oriented patterns.

>>> Coordinate system and rotations
Vortex uses a left handed coordinate system where X points right, Y points up, and Z points away from the viewer.

Rotations are using euler angles expressed in degrees.

>>> Screen coordinates
In Vortex, coordinates 0,0 represent the top left corner of the screen, while coordinates DeviceWidth(), DeviceHeight() represent the bottom right. This is a common convention in many graphics libraries (like Mojo).

>>> Texture coordinates
Texture coordinates are mapped from the top left (coordinates 0,0) to the bottom right (coordinates 1,1).

>>> Triangle order
Front facing triangles are those that are mapped to the screen in clockwise order.

>>> Surfaces, meshes, and entities
A *surface* is a list of vertices and indices that when connected define a 3 dimensional shape. A surface also has a *material*, which defines its visual properties like color, textures used and shininess.

A *mesh* is a collection of surfaces that make up a single object. Basically, a mesh has as many surfaces as materials. A mesh can also have animation information (an array of bones).

An *entity* is anything that exists in your 3D world, and has a position, rotation and scale. There are many types of entities, such as cameras, lights and models. An entity by itself does not draw anything in your world, but some special types of entities do. For example, a *model* is a type of entity that puts a mesh in the world. Since a mesh could appear at many places in your world, you can have a single mesh object that can be used by several models.




# Class Bone

A bone contains a list of transformations to be applied to the geometry attached to it when using animations. Meshes can contains bones that animate the surfaces of the mesh (to make it walk, for example).

# Method New(name:String, parentIndex)
Creates a new bone with the specified name and parent index.

# Method Name:String() Property
Return the name of the bone.

# Method ParentIndex:Int() Property
Returns the parent index of the bone in the array of bones of the mesh that this bone belongs to, or -1 if it is the root bone in the mesh.

# Method InversePoseMatrix:Float[]() Property
Returns the inverse pose matrix.
You don't normally need to use this property.
It is used internally when rendering the geometry attached to the bone.

# Method AddPositionKey:Void(keyframe:Int, x:Float, y:Float, z:Float)
Adds a new position transformation to the bone at the specified keyframe.

# Method AddRotationKey:Void(keyframe:Int, w:Float, x:Float, y:Float, z:Float)
Adds a new rotation quaternion to the bone at the specified keyframe.

# Method AddScaleKey:Void(keyframe:Int, x:Float, y:Float, z:Float)
Adds a new scale transformation to the bone at the specified keyframe.

# Method NumPositionKeys:Int() Property
Returns the number of position keyframes in the bone.

# Method PositionKeyFrame:Int(index:Int)
Returns the frame number of the specified position keyframe. The value of `index` goes in the range `0 .. NumPositionKeys - 1`.

# Method PositionKeyX:Float(index:Int)
Returns the X coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. NumPositionKeys - 1`.

# Method PositionKeyY:Float(index:Int)
Returns the Y coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. NumPositionKeys - 1`.

# Method PositionKeyZ:Float(index:Int)
Returns the Z coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. NumPositionKeys - 1`.

# Method NumRotationKeys:Int() Property
Returns the number of rotation keyframes in the bone.

# Method RotationKeyFrame:Int(index:Int)
Returns the frame number of the specified rotation keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.

# Method RotationKeyW:Float(index:Int)
Returns the W quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.

# Method RotationKeyX:Float(index:Int)
Returns the X quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.

# Method RotationKeyY:Float(index:Int)
Returns the Y quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.

# Method RotationKeyZ:Float(index:Int)
Returns the Z quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.

# Method NumScaleKeys:Int() Property
Returns the number of scale keyframes in the bone.

# Method ScaleKeyFrame:Int(index:Int)
Returns the frame number of the specified scale keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.

# Method ScaleKeyX:Float(index:Int)
Returns the X coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.

# Method ScaleKeyY:Float(index:Int)
Returns the Y coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.

# Method ScaleKeyZ:Float(index:Int)
Returns the Z coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. NumRotationKeys - 1`.




# Class Camera Extends Entity

A camera is a type of `Entity` that represents the player in the 3D world. It has a position and rotation, a viewport that will indicate the region of the screen where the camera will be renderer, and other properties like the clear mode and projection settings.

# Const CLEAR_NONE : Int
# Const CLEAR_COLOR : Int
# Const CLEAR_SKYBOX : Int

# Method New(parent:Entity = Null)
Creates a new camera entity with the specified parent (if any).

# Method ViewportX:Int() Property
Returns the origin X coordinate of the region of the screen that the camera will be drawn to.

# Method ViewportY:Int() Property
Returns the origin Y coordinate of the region of the screen that the camera will be drawn to.

# Method ViewportWidth:Int() Property
Returns the width of the region of the screen that the camera will be drawn to.

# Method ViewportHeight:Int() Property
Returns the height of the region of the screen that the camera will be drawn to.

# Method ViewportX:Void(val:Int) Property
Sets the origin X coordinate of the region of the screen that the camera will be drawn to.

# Method ViewportY:Void(val:Int) Property
Sets the origin Y coordinate of the region of the screen that the camera will be drawn to.

# Method ViewportWidth:Void(val:Int) Property
Sets the width of the region of the screen that the camera will be drawn to.

# Method ViewportHeight:Void(val:Int) Property
Sets the height of the region of the screen that the camera will be drawn to.

# Method Viewport:Void(x:Int, y:Int, width:Int, height:Int)
Sets the region of the screen that the camera will be drawn to.

# Method ClearMode:Int() Property
Returns the clear mode for this camera. Depending on the value of this property, the viewport will be cleared with a plain color or a textured skybox before performing rendering.
| Value | Meaning
| Camera.CLEAR_NONE | Does not clear the viewport before rendering.
| Camera.CLEAR_COLOR | Clears the viewport with the color defined by the `ClearColor` property.
| Camera.CLEAR_SKYBOX | Clears the viewport with the skybox defined by the `World.SkyboxTexture` function (defaults to `Null`).

# Method ClearMode:Void(mode:Int) Property
Sets the clear mode for this camera. Depending on the value of this property, the viewport will be cleared with a plain color or a textured skybox before performing rendering.
| Value | Meaning
| Camera.CLEAR_NONE | Does not clear the viewport before rendering.
| Camera.CLEAR_COLOR | Clears the viewport with the color defined by the `ClearColor` property.
| Camera.CLEAR_SKYBOX | Clears the viewport with the skybox defined by the `World.SkyboxTexture` function (defaults to `Null`).

# Method ClearColor:Int() Property
Returns the clear color used by this camera in case that the `ClearMode` property is set to `Camera.CLEAR_COLOR`.

# Method ClearColor:Void(color:Int) Property
Sets the clear color used by this camera in case that the `ClearMode` property is set to `Camera.CLEAR_COLOR`.

# Method Orthographic:Bool() Property
Returns whether this camera uses an orthogrsphic projection.

# Method Orthographic:Void(ortho:Bool) Property
Sets the camera to use an orthographics instead of a perspective projection.

# Method FovY:Float() Property
Returns the vertical focal angle of the camera.

# Method FovY:Void(fovy:Float) Property
Sets the vertical focal angle of the camera.

# Method AspectRatio:Float() Property
Returns the aspect ratio of the camera.

# Method AspectRatio:Void(ratio:Float) Property
Sets the aspect ratio of the camera, usually the width of the viewport cast to float divided by the height.

# Method Near:Float() Property
Returns the distance of the near frustum plane of the camera.

# Method Near:Void(near:Float) Property
Sets the distance of the near frustum plane of the camera. Anything closer to the camera than this plane will not be drawn.

# Method Far:Float() Property
Returns the distance of the far frustum plane of the camera.

# Method Far:Void(far:Float) Property
Sets the distance of the far frustum plane of the camera. Anything further to the camera than this plane will not be drawn.

# Method Framebuffer:Framebuffer() Property
Returns the framebuffer into which this camera renders, or `Null` if it renders to the screen.

# Method Framebuffer:Void(fb:Framebuffer) Property
Sets the framebuffer into which this camera renders. Set it to `Null` to render to the screen.




# Class Color

While internally a color is treated as 4 float values (red, green, blue, alpha), this information is packed inside a single integer, and we work with color components that go from 0 to 255. This class allows you to pack the color components into a single color integer, and extract each component from the color. It also has a set of predefined constants with some commonly used colors.

# Const RED			: Int
# Const GREEN			: Int
# Const BLUE			: Int
# Const CYAN			: Int
# Const MAGENTA		: Int
# Const YELLOW		: Int
# Const BLACK			: Int
# Const WHITE			: Int
# Const GRAY			: Int
# Const LIGHT_GRAY	: Int
# Const DARK_GRAY		: Int
# Const ORANGE		: Int
# Const BROWN			: Int

# Function RGB:Int(r:Int, g:Int, b:Int, a:Int = 255)
Returns a color with the specified RGBA components.

# Function Red:Int(color:Int)
Returns the red component of the specified color.

# Function Green:Int(color:Int)
Returns the green component of the specified color.

# Function Blue:Int(color:Int)
Returns the blue component of the specified color.

# Function Alpha:Int(color:Int)
Returns the alpha component of the specified color.

# Function ChangeAlpha:Int(color:Int, newAlpha:Int)
Returns the specified color, but replacing the alpha with the value specified in `newAlpha`.




# Class Entity

# Const COLLISION_NONE		: Int
# Const COLLISION_SPHERE	: Int
# Const COLLISION_BOX		: Int

Everything that exists in the 3D world is an entity. Basically, an entity is an object which has a position, rotation and scale. This is the base class for all the types of elements that can be part of your world, like cameras, models, lights and sprites.

An entity can have a parent and a list of children. When a parent entity is moved, rotated or scaled, it affects all its children.

# Method New(parent:Entity)
Creates a new entity with the specified parent. By default, an entity is an empty object in your world, but it can be used as a reference point.

# Method Discard:Void()
Removes the entity from the world and deallocates its resources.

# Method Name:String() Property
Returns the name of the entity.

# Method Name:Void(name:String) Property
Sets the name of the entity.

# Method Parent:Entity() Property
Returns the parent of the entity.

# Method Parent:Void(p:Entity) Property
Sets the parent of the entity.

# Method NumChildren:Int() Property
Returns the number of children this entity has.

# Method Child:Entity(index:Int)
Returns the child at the specified `index`, which is a value in the range `0 .. NumChildren - 1`.

# Method Active:Bool() Property
Returns whether the entity is active or not. Inactive entities are not updated every frame.

# Method Active:Void(active:Bool) Property
Sets whether the entitiy is active or not. Inactive entities are not updated every frame.

# Method Visible:Bool() Property
Returns whether an entity is visible or not. Invisible entities are not drawn.

# Method Visible:Void(visible:Bool) Property
Sets whether the entity is visible or not. Invisible entities are not drawn.

# Method X:Float() Property
Returns the local X position of the entity (this is, not taking its parent transformation into account).

# Method Y:Float() Property
Returns the local Y position of the entity (this is, not taking its parent transformation into account).

# Method Z:Float() Property
Returns the local Z position of the entity (this is, not taking its parent transformation into account).

# Method X:Void(val:Float) Property
Sets the X position of an entity (relative to its parent).

# Method Y:Void(val:Float) Property
Sets the Y position of an entity (relative to its parent).

# Method Z:Void(val:Float) Property
Sets the Z position of an entity (relative to its parent).

# Method WorldX:Float() Property
Returns the X position of the entity in the world.

# Method WorldY:Float() Property
Returns the Y position of the entity in the world.

# Method WorldZ:Float() Property
Returns the Z position of the entity in the world.

# Method Position:Void(x:Float, y:Float, z:Float)
Sets the local position of the entity.

# Method Move:Void(x:Float, y:Float, z:Float, collideWithEntities:Bool = True)
Moves the entity from its current location, taking its orientation into account. If `collideWithEntities`is set to `True` and `CollisionMode` is different to `Entity.COLLISION_NONE`, then collision woth other entities will be performed during movement. Static collisions will always be checked if the entitiy's `CollisionMode` is different to `Entity.COLLISION_NONE`. The entity will not reach its destination point if a collision is detected.

# Method Pitch:Float() Property
Returns the pitch of X rotation of the entity.

# Method Yaw:Float() Property
Returns the yaw of Y rotation of the entity.

# Method Roll:Float() Property
Returns the roll of Z rotation of the entity.

# Method Pitch:Void(val:Float) Property
Sets the pitch or X rotation of the entity.

# Method Yaw:Void(val:Float) Property
Sets the yaw or Y rotation of the entity.

# Method Roll:Void(val:Float) Property
Sets the roll or Z rotation of the entity.

# Method Rotate:Void(pitch:Float, yaw:Float, roll:Float)
Sets the rotation of the entity.

# Method Turn:Void(pitch:Float, yaw:Float, roll:Float)
Adds a rotation to the entity.

# Method Width:Float() Property
Returns the total width of the entity.

# Method Height:Float() Property
Returns the total height of the entity.

# Method Depth:Float() Property
Returns the total depth of the entity.

# Method ScaleX:Float() Property
Returns the X scale factor of the entity.

# Method ScaleY:Float() Property
Returns the Y scale factor of the entity.

# Method ScaleZ:Float() Property
Returns the Z scale factor of the entity.

# Method ScaleX:Void(val:Float) Property
Sets the X scale factor of the entity.

# Method ScaleY:Void(val:Float) Property
Sets the Y scale factor of the entity.

# Method ScaleZ:Void(val:Float) Property
Sets the Z scale factor of the entity.

# Method Scale:Void(x:Float, y:Float, z:Float)
Sets the scale factor of the entity.

# Method CollisionMode:Int() Property
Returns the collision mode for the entity. Default is `Entity.COLLISION_NONE`.

# Method CollisionMode:Void(mode:Int) Property
Sets the collision mode for the entity. Possible values are:

| Value | Meaning
| Entity.COLLISION_NONE | Do not check for collisions.
| Entity.COLLISION_SPHERE | Check for collisions using the entity's radius.
| Entity.COLLISION_BOX | Check for collisions using the entity's bounding box.

# Method Radius:Float() Property
Returns the radius of the entity. This is used for collision detection when `CollisionMode` is set to `Entity.COLLISION_SPHERE`.

# Method Radius:Void(rad:Float) Property
Sets the radius of the entity. This is used for collision detection when `CollisionMode` is set to `Entity.COLLISION_SPHERE`.

# Method Collided:Bool() Property
Returns whether the entity collided on the last movement or not.

# Method CollidedEntity:Entity() Property
Returns the entity that was collided on the last movement.

# Method Distance:Float(other:Entity)
Returns the distance to another entity.

# Method NumMaterials:Int() Property
Returns the number of materials that this entity has.

# Method Material:Material(index:Int)
Returns the entity's material with the specified index, which is a value between `0` and `NumMaterials - 1`.

# Method Material:Material() Property
Returns the first material of this entity.

# Method ReplaceMaterials:Void(mat:Material)
Replaces all materials in the entity with the specified one.

# Method EmitSound:Void(sound:Sound, radius:Float, channel:Int)
Emits a sound from the entity's position. The value of `radius` will be the maximum distance at which the sound can be heard.

# Method BoxMinX:Float() Property
Returns the origin X coordinate of the bounding box that wraps the entity.

# Method BoxMinY:Float() Property
Returns the origin Y coordinate of the bounding box that wraps the entity.

# Method BoxMinZ:Float() Property
Returns the origin Z coordinate of the bounding box that wraps the entity.

# Method BoxMaxX:Float() Property
Returns the final X coordinate of the bounding box that wraps the entity.

# Method BoxMaxY:Float() Property
Returns the final Y coordinate of the bounding box that wraps the entity.

# Method BoxMaxZ:Float() Property
Returns the final Z coordinate of the bounding box that wraps the entity.

# Method UserData:Object() Property
Returns the custom object associated with this entity.

# Method UserData:Void(data:Object) Property
Associates a custom object with this entity. This can be any object that you might want to associate with the entity (for example, an object with physics or gameplay information).




# Class Font

A font is used to render text in Vortex.
It is composed by a texture which contains the characters used to render texts, and a set of glyphs which contains the coordinates of each character within the texture and its offset.
You normally don't generate fonts by hand, but by using the bundled fonttool utility.

# Function Load(filename:String, cache:Bool = True)
Loads and returns the font with the specified filename, or `Null` if the font could not be loaded.
If `cache` is `True` and you call this function several times with the same filename, the same object will be returned (this is, it won't load one font more than once).

# Method Discard:Void()
When you are not going to render text usign this font anymore, you should call this method to deallocate its resources.

# Method Filename:String() Property
Returns the filename of the font.

# Method Height:Float() Property
Returns the height in pixels of the font.

# Method Texture:Texture() Property
Returns the texture map for this font.

# Method TextWidth:Float(text:String)
Returns the width in pixels that the specified text needs to be rendered with the font.

# Method TextHeight:Float(text:String)
Returns the width in pixels that the specified text needs to be rendered with the font.

# Method Draw:Void(x:Float, y:Float, text:String)
Draws the specified text at the given x, y screen coordinates.




# Class Framebuffer

A framebuffer can be used to perform rendering to a texture. It can also optionally have a depth buffer to perform depth testing when rendering.

# Method New(width:Int, height:Int, depthBuffer:Bool)
Creates a framebuffer with the specified size and an optional depth buffer.

# Method Discard:Void()
When you no longer need a framebuffer, you should call this method.

# Method Use:Void()
Enables rendering to the textures in this framebuffer.

# Function UseScreen:Void()
Reactivates rendering on the screen.

# Method Handle:Int() Property
Returns the internal handle of this framebuffer. This is an identifier in video memory, and you don't normally need to use this value.

# Method ColorTexture:Texture() Property
Returns the texture where this framebuffer renders the scene.

# Method HasDepthBuffer:Bool() Property
Indicates whether this framebuffer has a depth buffer or not.




# Class Light Extends Entity

Vortex supports defining lights sources that can shine on objects.
By default, the maximum number of lights that can be defined simultaneously is 4, although this value can be changed when calling `World.Init`.

When a light ray hits an object, the color of the light is combined with the color of the object, and that defines the appearance of the object.
This is called *diffuse lighting*.

Also, an object can have a shininess power, which will produce highlights when a light ray hits the objects. This gives the appearance of a shiny object, like a metal surface, and is called *specular lighting*.

Finally, independently from how many light rays are hitting an object, every object also receives some amount of residual lighting, produced by all the lights. This is called *ambient lighting*.
For example, if we are in a sunny open environment, the amount of ambient lighting is much bigger than in a narrow, dark cave, because the intensity of all the lights produce a brighter residual lighting.

Currently, all light sources are **point lights**, this is, they emit light in all directions. The `World` class controls the sun light, which is a directional light that emits in one specific direction.

# Method New(parent:Entity = Null)
Creates a new point light.

# Method Color:Int() Property
Returns the color of the light.

# Method Color:Void(color:Int) Property
Sets the color that the specified light emits. White by default.




# Class Listener

Vortex can simulate positional 3D sound by using the standard `mojo.audio` module. The `Listener` class is used to indicate which entity is the listener in your 3D world. The first camera that is created automatically becomes the active listener.

# Function Instance:Entity()
Returns the instance that is the active listener.

# Function Instance:Void(e:Entity)
Sets the instance that is the active listener. The first camera that is created automatically becomes the active listener.

# Function AvailableChannel:Int()
Returns an available channel number (one that is not currently being used) that you can use with `Entity.EmitSound`.




# Class Material

A material represents the visual information such as textures, color, or shininess.
It is used to render objects with a specific appearance.

# Method New(colorTex:Texture = Null)
Creates a new material with the specified color texture.

# Method New(other:Material)
Creates a new material that is a copy of another one.

# Method DiscardTextures:Void()
Frees the textures used by this material.
If the textures of the material are not shared by other material, you should call this method to free the textures memory when the material is no longer needed.
You do not need to call this method if you cahce the textures (which is the default behaviour).

# Method IsEqual:Bool(other:Material)
Returns whether the material has the same propierties as the one passed as parameter or not.

# Method Set:Void(other:Material)
Sets the properties of the material to be those of the one passed as parameter.

# Method Shader:Void(shader:Shader) Property
Sets the shader that this material uses. If you want to use the default builtin shader, set it to `Null`.

# Method Shader:Shader() Property
Returns the shader that this material uses, or `Null` if the material uses the default builtin shader.

# Method Color:Void(color:Int) Property
Sets the color of the material.

# Method Color:Int() Property
Returns the color of the material.

# Method ColorTexture:Void(tex:Texture) Property
Sets the color texture of the material. It can be either a 2D or cubemap texture.
If it is a cubemap, it will be rendered as a skybox, and you should not set a `CubeTexture`.

# Method ColorTexture:Texture() Property
Returns the color texture of the material, or `Null` if there is no color texture.

# Method NormalTexture:Void(tex:Texture) Property
Sets the normal texture of the material.

# Method NormalTexture:Texture() Property
Returns the normal texture of the material, or `Null` if there is no normal texture.

# Method SpecularTexture:Void(tex:Texture) Property
Sets the specular texture of the material, which is expected to be a grayscale image. When there is a specular texture set, the `Shininess` property of the material is multiplied with the values on this texture to provide a variable shininess across the surface of the object. When you set a specular texture, the `Shininess` property is expected to be greater than zero.

# Method SpecularTexture:Texture() Property
Returns the specular texture of the material, or `Null` if there is no specular texture.

# Method LightTexture:Void(tex:Texture) Property
Sets the light texture of the material.

# Method LightTexture:Texture() Property
Returns the light texture of the material, or `Null` if there is no light texture.

# Method CubeTexture:Void(tex:Texture) Property
Sets the cubemap texture of the material.
If the value of `RefractionCoef` is negative, the cubemap will be reflective (like a metal), while if it is positive, it will be refractive (like glass or water).

# Method CubeTexture:Texture() Property
Returns the cubemap texture of the material, or `Null` if there is no cubemap texture.

# Method Opacity:Void(opacity:Float) Property
Sets the opacity of the material, with 0 being completely transparent and 1 being completely opaque. The default value is 1.

# Method Opacity:Float() Property
Returns the opacity of the material, in the range 0 (transparent) .. 1 (opaque).

# Method Shininess:Void(shininess:Float) Property
Sets the specular shininess of the material. A value of 0 will disable specular reflections entirely, whereas a value in the range (0,1] will indicate the strength of the specular reflection.

# Method Shininess:Float() Property
Returns the specular shininess of the material.

# Method CubeOpacity:Void(opacity:Float) Property
Sets the opacity of the cubemap. The default opacity is 0.5.

# Method CubeOpacity:Float() Property
Return the opacity of the cubemap.

# Method RefractionCoef:Void(coef:Float) Property
Sets the refraction coefficient of the material.
This should be the refraction value of the source medium divided by the refraction value of the destination medium.
For example, to define the refraction of light entering water from air, it would be 1.0 / 1.33.

If this value is positive, it is used to calculate the refraction of the `CubeTexture` property.
If it is negative, then this value is ignored and the `CubeTexture` is assumed to be a reflection map.
Its default value is -1.

# Method RefractionCoef:Float() Property
Returns the refraction coefficient of the material.

# Method BlendMode:Void(mode:Int) Property
Sets the blend mode of the material. This defines how the final look of the geometry using this material blends with the background, after computing texture, color and lighting information.

It takes one of the following values:

| Value             | Meaning
| Renderer.BLEND_SOLID | The object is solid and it is not blended with the background. This is the default value.
| Renderer.BLEND_ALPHA | The computed alpha value of the material (taking into account both material alpha and texture alpha values) is used to blend with the background.
| Renderer.BLEND_ADD   | The computed color of the material is added to the background. This is useful to render "glow" geometry, such as fire and lasers.
| Renderer.BLEND_MUL   | The computed color of the material is multiplied with the background. This is useful to render lightmap geometry on top of other geometry.

# Method BlendMode:Int() Property
Returns the blend mode of the material.

# Method Lighting:Void(enable:Bool) Property
Enables or disables lighting for this material. It is enabled by default. This only has effect if the world's sun light is activated (not black), or there are light sources present.

# Method Lighting:Bool() Property
Returns whether lighting is calculated for this material.

# Method Culling:Void(enable:Bool) Property
Enables or disables backface culling. When it is enabled, internal faces of the geometry using this material will not be rendered. It is enabled by default.

# Method Culling:Bool() Property
Returns whether backface culling is enabled.

# Method DepthWrite:Void(enable:Bool) Property
Enables or disables depth buffer writing. When it is disabled, other geometry further away from the viewer may occlude the geometry that uses this material. It is enabled by default.

# Method DepthWrite:Bool() Property
Returns whether depth buffer writing is enabled.

# Method CastShadows:Void(enable:Bool) Property
Enables or disables shadow casting. It is enabled by default. Only used if blend mode is `Renderer.BLEND_SOLID`.

# Method CastShadows:Bool() Property
Returns whether shadow casting is enabled.

# Method ReceiveShadows:Void(enable:Bool) Property
Ensables or disables shadows on this material. It is enabled by default.
	
# Method ReceiveShadows:Bool() Property
Returns whether this material receives shadows.




# Class Mesh

A mesh is the description of a set of geometry (triangles), materials and optional animations that belong to one object.
For every material that we have, there will be a surface in the mesh containing the geometry to be drawn with that material.

# Method New()
Creates a new empty mesh.

# Method New(other:Mesh)
Creates a new mesh that is a copy of the mesh passed as parameter.

# Function Load(filename:String, skeletonFilename:String = "", animationFilename:String = "", texFilter:Int = Renderer.FILTER_TRILINEAR, cache:Bool = True)
Loads and returns the mesh with the specified filename, or `Null` if the mesh could not be loaded. You can also specify a skeleton and animation files that will be loaded with the mesh.
If `cache` is `True` and you call this function several times with the same filename, the same object will be returned (this is, it won't load one mesh more than once).

# Method LoadSkeletonData:Bool(data:DataBuffer)
Loads the skeleton data from the specified DataBuffer and adds it to the mesh. You should only use this method once on each mesh.

# Method LoadAnimationData:Bool(data:DataBuffer)
Loads the animation data from the specified DataBuffer and adds it to the mesh. You can call this funcion several times to add different animation sequences.

# Method Discard:Void(discardTextures:Bool = True)
When you don't need to use this mesh anymore, you should use this function to deallocate its resources.
The parameter `discardTextures` indicates whether the textures used by this mesh should be discarded too.
You don't need to call this method for meshes loaded with the `cache` param set to `True` (the default).

# Method Filename:String() Property
Returns the filename assigned to this mesh when it was created.

# Method AddSurface:Void(surf:Surface, mat:Material = Null)
Creates a new surface on the mesh and returns its handle.
A surface is a set of geometry that use the same material and it's attached to a same bone (if the mesh is animated).
If you don't provide a material, a new one will be created automatically for the surface.

# Method NumSurfaces:Int() Property
Returns the number of surfaces that this mesh contains.

# Method Surface:Surface(index:Int) Property
Returns a surface contained in the mesh. The value of `index` must be in the range `0 .. NumSurfaces - 1`.

# Method Material:Material(index:Int)
Returns a material contained in the mesh. The value of `index` must be in the range `0 .. NumSurfaces - 1`.

# Method NumFrames:Void(lastFrame:Int) Property
Sets the number of animation frames for the mesh. You should call this method only when generating an animated mesh procedurally, but not when loading the mesh from disk.

# Method NumFrames:Int() Property
Returns the number of animation frames contained in the mesh.

# Method AddBone:Void(bone:Bone)
Adds a new bone to the mesh.

# Method NumBones:Int() Property
Gets the number of bones in the mesh.

# Method Bone:Bone(index:Int)
Gets the bone at the specified `index`, which is a value between `0` and `NumBones - 1`.

# Method Width:Float() Property
Returns the width of the mesh.

# Method Height:Float() Property
Returns the height of the mesh.

# Method Depth:Float() Property
Returns the depth of the mesh.

# Method UpdateBoundingBox:Void()
Updates the bounding box of the mesh. This method should be called if you have added vertices or modified the position of any vertex in the mesh.

# Method BoxMinX:Float() Property
Returns the origin X coordinate of the bounding box that wraps the mesh.

# Method BoxMinY:Float() Property
Returns the origin Y coordinate of the bounding box that wraps the mesh.

# Method BoxMinZ:Float() Property
Returns the origin Z coordinate of the bounding box that wraps the mesh.

# Method BoxMaxX:Float() Property
Returns the final X coordinate of the bounding box that wraps the mesh.

# Method BoxMaxY:Float() Property
Returns the final Y coordinate of the bounding box that wraps the mesh.

# Method BoxMaxZ:Float() Property
Returns the final Z coordinate of the bounding box that wraps the mesh.

# Method Translate:Void(x:Float, y:Float, z:Float)
Translates all vertices in the mesh.

# Method Rotate:Void(pitch:Float, yaw:Float, roll:Float)
Rotates all vertices on the mesh.

# Method Scale:Void(x:Float, y:Float, z:Float)
Scales all vertices on the mesh.

# Method Flip:Void()
Flips all triangles in the mesh and inverts its normals.

# Method ColorVertices:Void(color:Int)
Sets the color of all vertices in the mesh.

# Function CreateQuad:Mesh()
Creates a quad mesh with a width and height of 1.

# Function CreateCube:Mesh()
Creates a cube mesh with a width, height and depth of 1.

# Function CreateSkybox:Mesh()
Creates a skybox with a width, height and depth of 1.

# Function CreateWedge:Mesh()
Creates a wedge mesh with a width, height and depth of 1.




# Class Model Extends Entity

This type of entity represents an object with 3D geometry in your world. A model basically renders a triangle mesh with a specific position, rotation and scale, and supports mesh animation. Several models can shader the same mesh.

# Method New(mesh:Mesh, parent:Entity = Null)
Creates a new model from the specific mesh and parent. The value of `mesh` should not be `Null`.

# Method Mesh:Mesh() Property
Returns the mesh that this model uses.

# Method FPS:Float() Property
Returns the frames per second at which this model animates (default is 0).

# Method FPS:Void(fps:Float) Property
Sets the frames per second at which this model animates (default is 0).

# Method CurrentFrame:Float() Property
Returns the current animation frame of the model.

# Method FirstFrame:Int() Property
Returns the first frame in the animation sequence.

# Method FirstFrame:Void(frame:Int) Property
Sets the first frame in the animation sequence.

# Method LastFrame:Int() Property
Returns the last frame in the animation sequence.

# Method LastFrame:Void(frame:Int) Property
Sets the last frame in the animation sequence.




# Class Renderer

The Renderer is the class used to draw graphics on the screen in immediate mode, and the direct link with the underlying rendering API (OpenGL). For most stuff, you do not need to deal with this class directly, but for example if you want to draw your 2D graphics above the 3D scene, after drawing all your 3D geometry, you must call `Renderer.Setup2D` to setup the context for 2D drawing, and then perform your drawing operations.

# Function Setup2D:Void(x:Int, y:Int, width:Int, height:Int)
Setups the context for 2D drawing. The parameters define the rectangle within the screen where drawing will take place. You must call this function before doing any 2D drawing.

# Function SetupMojo:Void()
Setups the context for drawing with Mojo2.

# Function BlendMode:Void(mode:Int)
Sets the blend mode to use when painting. Possible values are:

| Value       | Meaning
| Renderer.BLEND_SOLID | The object is solid and it is not blended with the background. This is the default value.
| Renderer.BLEND_ALPHA | The computed alpha value of the material (taking into account both material alpha and texture alpha values) is used to blend with the background.
| Renderer.BLEND_ADD   | The computed color is added to the background. This is useful to render "glow" geometry, such as fire and lasers.
| Renderer.BLEND_MUL   | The computed color is multiplied with the background. This is useful to render lightmap geometry on top of other geometry.

# Function Color:Void(color:Int)
Sets the drawing color.

# Function ClearColorBuffer:Void(color:Int = Color.BLACK)
Clears the background (actually, the area defined when the call to `Renderer.Setup2D` was made) with the specified color.

# Function DrawPoint:Void(x:Float, y:Float, z:Float)
Draws a point at the specified coordinates. For 2D graphics, `z` should be 0.

# Function DrawLine:Void(x1:Float, y1:Float, z1:Float, x2:Float, y2:Float, z2:Float)
Draws a line that goes from x1, y1 to x2, y2. For 2D graphics, both `z1` and `z2` should be 0.

# Function DrawRect:Void(x:Float, y:Float, z:Float, width:Float, height:Float)
Draws a filled rectangle at the specified coordinates, with the given width and height. For 2D graphics, `z` should be 0.

# Function DrawEllipse:Void(x:Float, y:Float, z:Float, width:Float, height:Float)
Draw a filled ellipse at the specified coordinates, with the given width and height. For 2D graphics, `z` should be 0.




# Class Shader

A shader is a program that runs on the GPU to perform the drawing of all elements on the screen. Every material has a shader assigned.
Vortex comes with default shaders for 2D & 3D drawing, but you can create your own shaders.

A shader is created from two strings: one to define vertex transformation and another to perform fragment coloring. Shaders are written using GLSL ES 1.00. Every shader that you create automaticaly includes the following before your own code:

<pre>
#ifdef GL_ES
precision mediump int;
precision mediump float;
#endif
#define MAX_LIGHTS <Max number of lights defined in World.Init>
#define MAX_BONES <Max number of bones defined in World.Init>
</pre>

Documentation of this class will come soon!




# Class Sprite Extends Entity

A sprite is a 2D object in a 3D world. It has width and height, but no depth. It can be oriented automatically so that it always faces the camera.

# Const MODE_STATIC		: Int
# Const MODE_SPHERICAL	: Int
# Const MODE_CYLINDRICAL	: Int

# Method New(texture:Texture, hframes:Int = 1, vframes:Int = 1, orientation:Int = MODE_SPHERICAL, parent:Entity = Null)
Creates a new sprite with the specified texture. The size of the sprite will be set to the size of the texture. The parameters `hframes` and `vframes` indicate the number of horizontal and vertical animation frames contained in the texture. The value of `orientation` can be:

| Value       | Meaning
| Sprite.MODE_STATIC | The sprite does not rotate to face the camera.
| Sprite.MODE_SPHERICAL   | The sprite rotates freely to face the camera.
| Sprite.MODE_CYLINDRICAL   | The sprite rotates on its Y axis to face the camera.

# Method Orientation:Int() Property
Returns the orientation mode of the sprite.

# Method Orientation:Void(orientation:Int) Property
Sets the orientation mode of the sprite. It can be one of the following values:

| Value       | Meaning
| Sprite.MODE_STATIC | The sprite does not rotate to face the camera.
| Sprite.MODE_SPHERICAL   | The sprite rotates freely to face the camera.
| Sprite.MODE_CYLINDRICAL   | The sprite rotates on its Y axis to face the camera.

# Method Spin:Float() Property
Returns the spin rotation of the sprite.

# Method Spin:Void(spin:Float) Property
Sets the spin rotation of the sprite.

# Method Size:Void(width:Float, height:Float)
Sets the width and height of the sprite.

# Method Frames:Int() Property
Returns the total number of frames that this sprite has (1 by default).

# Method HFrames:Int() Property
Returns the number of horizontal frames that this sprite has (1 by default).

# Method VFrames:Int() Property
Returns the number of vertical frames that this sprite has (1 by default).

# Method Frames:Void(horizontal:Int, vertical:Int)
Sets the number of horizontal and vertical frames that this sprite has.

# Method FPS:Int() Property
Returns the animation frames per second of the sprite.

# Method FPS:Void(fps:Int) Property
Sets the animation frames per second of the sprite. To play the sequence backwards, set this to a negative value.

# Method CurrentFrame:Int() Property
Returns the animation frame currently being displayed by the sprite.

# Method CurrentFrame:Void(frame:Int) Property
Forces the sprite to show the specified animation frame. This can be used to animate the sprite manually.




# Class Stats

This class stores some statistics like the elapsed time since the last update and the screen FPS.

# Function DeltaTime:Float()
Returns the elapsed time in seconds since the last update.

# Function FPS:Int()
Returns the current screen FPS.

# Function RenderCalls:Int()
Returns the number of render calls performed in the last call to `World.Render`.

# Function ShaderError:String()
Reports any errors that took place while compiling the shaders on initialization.

# Function VendorName:String()
Returns the name of the vendor of the renderer implementation.
	
# Function RendererName:String()
Returns the name of the renderer implementation.
	
# Function APIVersionName:String()
Returns the API version name as provided by the driver.
	
# Function ShadingVersionName:String()
Returns the shading language version name as provided by the driver.

# Function APIVersion:Float()
Get the version of the API supported by this machine (currently, the version of OpenGL supported by the implementation).

# Function ShadingVersion:Float()
Get the version of the shading language supported by this machine (currently, the version of GLSL supported by the implementation).

# Function MaxTextureSize:Int()
Returns the maximum texture size supported by the device.




# Class Surface

The surface class contains a set of geometry (vertices and indices that form triangles) and a material to draw that geometry.

# Method New(mode:Int = Renderer.MODE_TRIANGLES)
Creates a new surface with the specified drawing mode. It must be one of:

| Value | Meaning
| Renderer.MODE_POINTS | Every vertex in the surface represents a point.
| Renderer.MODE_LINES | Every 2 vertices in the surface represents a line.
| Renderer.MODE_TRIANGLES | Every 3 vertices in the surface represents a triangle (this is the default mode).
| Renderer.MODE_TRIANGLESTRIP | Every vertex is connected to the two previous ones to make triangles.
| Renderer.MODE_TRIANGLEFAN | Every vertex is connected to the first and the previous ones to make triangles.

# Method New(other:Surface)
Creates a new surface that is a copy of the one passed as parameter.

# Method Discard:Void()
Deallocates all the resources used by this surface. You don't normally need to call this method directly, since meshes call this method on all their surfaces when the mesh itself is freed.

# Method Mode:Int() Property

Returns the drawing mode of the surface. It can be one of:

| Value | Meaning
| Renderer.MODE_POINTS | Every vertex in the surface represents a point.
| Renderer.MODE_LINES | Every 2 vertices in the surface represents a line.
| Renderer.MODE_TRIANGLES | Every 3 vertices in the surface represents a triangle (this is the default mode).
| Renderer.MODE_TRIANGLESTRIP | Every vertex is connected to the two previous ones to make triangles.
| Renderer.MODE_TRIANGLEFAN | Every vertex is connected to the first and the previous ones to make triangles.

# Method Set:Void(other:Surface)
Sets this surface's material and geometry data to copy those of the mesh passed as parameter. The surface is automatically rebuilt.

# Method AddIndex:Int(i:Int)
Adds a new index to the surface. Depending on the drawing mode, each primitive will require a different number of indices:

| Mode | Indices per primitive
| Renderer.MODE_POINTS | 1
| Renderer.MODE_LINES | 2
| Renderer.MODE_TRIANGLES | 3
| Renderer.MODE_TRIANGLESTRIP | 3 for the first one, 1 for the rest.
| Renderer.MODE_TRIANGLEFAN | 3 for the first one, 1 for the rest.

Returns the number of indices before adding this one.

# Method NumIndices:Int() Property
Returns the number of indices int he surface.

# Method Index:Void(num:Int, v:Int)
Sets the value of the specified index number.

# Method Index:Int(num:Int)
Returns the value of the specified index number.

# Method AddTriangle:Int(v0:Int, v1:Int, v2:Int)
Adds a new triangle to the surface if the drawing mode is `Renderer.MODE_TRIANGLES` and returns the index of the triangle within the surface.
In this drawing mode, a triangle contains three indices, that reference the vertices in the surface.
If the drawing mode is not `Renderer.MODE_TRIANGLES`, this function does nothing and returns `-1`.
This is just a convenience method you can use instead of making three calls to `Surface.AddIndex`.

# Method NumTriangles:Int() Property
Returns the number of triangles in the surface.

# Method Triangle:Void(tri:Int, v0:Int, v1:Int, v2:Int)
Changes the vertex indices used by a specified triangle if the drawing mode is `Renderer.MODE_TRIANGLES`. Otherwise, it does nothing.

# Method TriangleV0:Int(tri:Int)
Returns the index of the first vertex in the specified triangle if the drawing mode is `Renderer.MODE_TRIANGLES`. Otherwise, it returns -1.

# Method TriangleV1:Int(tri:Int)
Returns the index of the second vertex in the specified triangle if the drawing mode is `Renderer.MODE_TRIANGLES`. Otherwise, it returns -1.

# Method TriangleV2:Int(tri:Int)
Returns the index of the third vertex in the specified triangle if the drawing mode is `Renderer.MODE_TRIANGLES`. Otherwise, it returns -1.

# Method AddVertex:Int(x:Float, y:Float, z:Float, nx:Float, ny:Float, nz:Float, color:Int, u:Float, v:Float)
Adds a new vertex to the surface, with the given position, normal, color, and texture coordinates. Returns the index of the vertex within the surface.

# Method NumVertices:Int() Property
Returns the number of vertices in the surface.

# Method VertexPosition:Void(index:Int, x:Float, y:Float, z:Float)
Sets the position of the specified vertex.

# Method VertexNormal:Void(index:Int, nx:Float, ny:Float, nz:Float)
Sets the normal vector of the specified vertex.

# Method VertexColor:Void(index:Int, color:Int)
Sets the color of the specified vertex.

# Method VertexTexCoords:Void(index:Int, u:Float, v:Float, set:Int = 0)
Sets the texture coordinates of the specified vertex.

# Method VertexBone:Void(vertex:Int, index:Int, bone:Int, weight:Float)
Sets one of the bones that the vertex is attached to, and the weight that the bone has on the vertex (between 0 and 1).
A vertex can be attached to a maximum of four bones, specified in the `index` parameter with a value between 0 and 3.
Bone is the index within the mesh of the specified bone.

# Method VertexX:Float(index:Int)
Returns the X position of the specified vertex.

# Method VertexY:Float(index:Int)
Returns the Y position of the specified vertex.

# Method VertexZ:Float(index:Int)
Returns the Z position of the specified vertex.

# Method VertexNX:Float(index:Int)
Returns the X component of the normal of the specified vertex.

# Method VertexNY:Float(index:Int)
Returns the Y component of the normal of the specified vertex.

# Method VertexNZ:Float(index:Int)
Returns the Z component of the normal of the specified vertex.

# Method VertexColor:Int(index:Int)
Returns the color of the specified vertex.

# Method VertexU:Float(index:Int, set:Int = 0)
Returns the U texture coordinate of the specified vertex.

# Method VertexV:Float(index:Int, set:Int = 0)
Returns the V texture coordinate of the specified vertex.

# Method VertexBoneIndex:Int(vertex:Int, index:Int)
Returns the specified vertex bone index.

# Method VertexBoneWeight:Float(vertex:Int, index:Int)
Return the specified vertex bone weight.

# Method Translate:Void(x:Float, y:Float, z:Float)
Translates all vertices in the surface.

# Method Rotate:Void(pitch:Float, yaw:Float, roll:Float)
Rotates all vertices on the surface.

# Method Scale:Void(x:Float, y:Float, z:Float)
Scales all vertices on the surface.

# Method Flip:Void()
Flips all triangles in the surface and inverts its normals.

# Method ColorVertices:Void(color:Int)
Sets the color of all vertices in the surface.

# Method Rebuild:Void()
Rebuilds the internal representation of the geometry in the surface.
To increase rendering performance, Vortex holds a copy of the data of all surfaces in video memory, so whenever you make a change to the geometry of a surface, you must call this function so the video memory is updated.

# Method Draw:Void()
Draws the surface. You don't normally need to call this function, because you will draw surfaces through a `RenderBatch`.




# Class Texture

A texture represents a buffer in video memory that contains pixel data.
Textures can be contained in materials and applied to objects together with other information like color and opacity, or drawn to the screen directly (for example to render 2D sprites).

# Method New(width:Int, height:Int)
Creates a blank texture with the specified width and height. This function is used by framebuffers to create the texture to render the scene into. Its filtering is set to `Renderer.FILTER_NONE`.

# Method New(buffer:DataBuffer, width:Int, height:Int, filter:Int = Renderer.FILTER_TRILINEAR)
Creates a texture with the specified size and filter mode, and the pixels stored in the data buffer. The value of `filter` must be one of:

* Renderer.FILTER_NONE
* Renderer.FILTER_LINEAR
* Renderer.FILTER_BILINEAR
* Renderer.FILTER_TRILINEAR

# Function Load(filename:String, filter:Int = Renderer.FILTER_TRILINEAR, cache:Bool = True)
Loads and returns the texture with the specified filename, or `Null` if the texture could not be loaded.
If `cache` is `True` and you call this function several times with the same filename, the same object will be returned (this is, it won't load one texture more than once).
The value of `filter` must be one of:

* Renderer.FILTER_NONE
* Renderer.FILTER_LINEAR
* Renderer.FILTER_BILINEAR
* Renderer.FILTER_TRILINEAR

# Function Load(left:String, right:String, front:String, back:String, top:String, bottom:String, filter:Int = Renderer.FILTER_TRILINEAR, cache:Bool = True)
Loads and returns the cubemap texture with the specified filenames (one for each face of the cube), or `Null` if the texture could not be loaded.
If `cache` is `True` and you call this function several times with the same filename, the same object will be returned (this is, it won't load one texture more than once).
The value of `filter` must be one of:

* Renderer.FILTER_NONE
* Renderer.FILTER_LINEAR
* Renderer.FILTER_BILINEAR
* Renderer.FILTER_TRILINEAR

# Method Discard:Void()
Discards the resources used by this texture.
If you loaded the texture with the `cache` param set to `True` (the default), then you must not call this function.
Otherwise, you must call this function when you no longer need the texture.

# Method Filename:String() Property
Returns the filename that this texture was created from.

# Method Handle:Int() Property
Returns the internal handle of this texture. This is an identifier in video memory, and you don't normally need to use this value.

# Method Width:Int() Property
Returns the width, in pixels, of the texture.

# Method Height:Int() Property
Returns the height, in pixels, of the texture.

# Method IsCubic:Bool() Property
Returns whether the texture is a cube map.

# Method Draw:Void(x:Float, y:Float, width:Float = 0, height:Float = 0, rectx:Float = 0, recty:Float = 0, rectwidth:Float = 0, rectheight:Float = 0)
Draws the texture to the specified screen coordinates.
You can also specifY a width and a height different than its original size, and a rectangle within the texture to draw instead of the whole thing.




# Class World

# Function Init:Bool(numLights:Int = 4, numBones:Int = 75)
Initializes the Vortex library. This should be called before any other function in the library.
You can override the maximum number of lights in the world and the maximum number of bones per mesh.

# Function Update:Void()
Updates all entities in the world. This should be called on the app's `OnUpdate` method.

# Function Render:Void()
Renders the world. This should be called on the app's `OnRender` method.

# Function SkyboxTexture:Texture()
Returns the cubemap texture that is used as background on camera's that have the `ClearMode` property set to `Camera.CLEAR_SKYBOX`. Defaults to `Null`.

# Function SkyboxTexture:Void(tex:Texture)
Sets the cubemap texture that is used as background on camera's that have the `ClearMode` property set to `Camera.CLEAR_SKYBOX`. Defaults to `Null`.

# Function NumEntities:Int()
Returns the number of entities that exist in the world.

# Function Entity:Entity(index:Int)
Returns the entity with the specified index, which goes in the range `0 ... NumEntities - 1`.

# Function FindEntity:Entity(name:String)
Returns the entitiy with the specified name, or `Null` if it does not exist.

# Function SunPitch:Float()
Returns the pitch rotation of the sun.

# Function SunYaw:Float()
Returns the yaw rotation of the sun.

# Function SunRotation:Void(pitch:Float, yaw:Float)
Sets the rotation of the sun.

# Function SunColor:Int()
Returns the color of the sun. Default is `Color.WHITE`.

# Function SunColor:Void(color:Int)
Sets the color of the sun. Setting it to `Color.BLACK` disables the sun light.

# Function Ambient:Int()
Returns the ambient color of the world (this is, the lighting that will be received by all geometry independent from the light sources).

# Function Ambient:Void(amb:Int)
Sets the ambient color of the world (this is, the lighting that will be received by all geometry independent from the light sources).

# Function FogEnabled:Bool()
Returns whether fog is enabled or not.

# Function FogEnabled:Void(enabled:Bool)
Enables or disables fog.

# Function FogMinDistance:Float()
Returns the distance at which the fog starts to be visible.

# Function FogMinDistance:Void(minDist:Float)
Sets the distance at which the fog starts to be visible.

# Function FogMaxDistance:Float()
Returns the distance at which the fog is completely opaque.

# Function FogMaxDistance:Void(maxDist:Float)
Sets the distance at which the fog is completely opaque.

# Function FogColor:Int()
Returns the color of the fog

# Function FogColor:Void(color:Int)
Sets the color of the fog.

# Function SeparateDepthPass:Bool()
Returns whether a separate depth pass is performed before rendering the rest of the scene.

# Function SeparateDepthPass:Void(enable:Bool)
Enables or disables a separate depth pass before rendering the scene. This can help reducing the amount of pixels processed in some situations.

# Function Shadows:Bool()
Returns whether shadows are enabled or not.

# Function Shadows:Void(enable:Bool, range:Float = 500, sunDistance:Float = 0, shadowTexSize:Int = 1024)
Enables or disables shadow casting. Shadows will be cast from the sun light.
The value of `range` indicates the maximum distance from the camera at which the shadow will be visible.
The value of `sunDistance` indicate the distance from the camera at which the sun will be placed to calculate shadows (the bigger this value, the smaller the precision of the calculations).
If you leave this value to `0`, the sun distance will be half of the range.

You can also set the size of the texture used for shadows calculation (quality increases with this value, but calculations will be slower).

# Function AddStaticCollisionBox:Void(x:Float, y:Float, z:Float, width:Float, height:Float, depth:Float)
Adds a box to the static collision list. This list contains global world collisions that do not belong to any entity.

# Function ClearStaticCollisions:Void()
Clears the static collision list.