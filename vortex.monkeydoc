# Module vortex

The Vortex module adds a very simple 3D rendering engine based on OpenGL ES 2.
More than a full 3D engine, it provides a lower-level API, similar to what the official Mojo module offers for 2D.

>>> Coordinate system and rotations
Vortex uses a left handed coordinate system where X points right, Y points up, and Z points away from the viewer.

Rotations can be expressed both using quaternions and euler angles (expressed in degrees).

>>> Screen coordinates
In Vortex, coordinates 0,0 represent the top left corner of the screen, while coordinates DeviceWidth(), DeviceHeight() represent the bottom right. This is a convention common in several graphics libraries (like Monkey's Mojo).

>>> Texture coordinates
Texture coordinates are mapped from the top left (coordinates 0,0) to the bottom right (coordinates 1,1).~n

>>> Triangle order
Front facing triangles are those that are mapped to the screen in clockwise order.~n




# Class Bone

A bone contains a list of transformations to be applied to the geometry attached to it when using animations. Meshes can contains bones that animate the surfaces of the mesh (to make it walk, for example).

# Function Create:Bone(name:String)
Creates a new bone with the specified name.

# Method GetName:String()
Returns the name of the bone.

# Method SetParent:Void(parent:Bone)
Sets the parent of the bone.

# Method GetParent:Bone()
Returns the parent of the bone, which will be another bone, or Null if it is the root bone in the mesh.

# Method SetLocalPoseMatrix:Void(matrix:Mat4)
Sets the pose matrix for this bone, which defines the position, rotation and scale, relative to its parent, to be applied to the bone when it is not being rendered animated.
Although this matrix must contain a transformation in local space, the global transformation is calculated and stored, so the parent's pose matrix must have been previously defined.
You don't need to use this function, unless you are generating meshes by hand. When loading a mesh from disk, this function will be called automatically by the loader.

# Method GetGlobalPoseMatrix:Mat4()
Returns the global pose transform matrix.
You don't normally need to call this function.
It is used internally when rendering the geometry attached to the bone.

# Method GetInverseGlobalPoseMatrix:Float[]()
Returns a 16 float array that contains the inverse of the global pose transform matrix.
You don't normally need to call this function.
It is used internally when rendering the geometry attached to the bone.

# Method AddPositionKey:Void(keyframe:Int, x:Float, y:Float, z:Float)
Adds a new position transformation to the bone at the specified keyframe.

# Method AddRotationKey:Void(keyframe:Int, w:Float, x:Float, y:Float, z:Float)
Adds a new rotation quaternion to the bone at the specified keyframe.

# Method AddScaleKey:Void(keyframe:Int, x:Float, y:Float, z:Float)
Adds a new scale transformation to the bone at the specified keyframe.

# Method GetNumPositionKeys:Int()
Returns the number of position keyframes in the bone.

# Method GetPositionKeyFrame:Int(index:Int)
Returns the frame number of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Method GetPositionKeyX:Float(index:Int)
Returns the X coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Method GetPositionKeyY:Float(index:Int)
Returns the Y coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Method GetPositionKeyZ:Float(index:Int)
Returns the Z coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Method GetNumRotationKeys:Int()
Returns the number of rotation keyframes in the bone.

# Method GetRotationKeyFrame:Int(index:Int)
Returns the frame number of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetRotationKeyW:Float(index:Int)
Returns the W quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetRotationKeyX:Float(index:Int)
Returns the X quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetRotationKeyY:Float(index:Int)
Returns the Y quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetRotationKeyZ:Float(index:Int)
Returns the Z quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetNumScaleKeys:Int()
Returns the number of scale keyframes in the bone.

# Method GetScaleKeyFrame:Int(index:Int)
Returns the frame number of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Method GetScaleKeyX:Float(index:Int)
Returns the X coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Method GetScaleKeyY:Float(index:Int)
Returns the Y coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Method GetScaleKeyZ:Float(index:Int)
Returns the Z coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.




# Class Cache

The cache is used to avoid loading resources from disk more that once.
When you want to load a resource from disk (a texture, a mesh, or a font), Vortex will check if the resource was already loaded, in which case the same instance is returned to you, so it is not loaded multiple times in memory.

Internally, Vortex holds a stack of cache objects. You can add a new cache with the `Cache.Push` function, and all the resources loaded afterwards will be deallocated when the cache object is removed from the stack with `Cache.Pop`.
For example, on game initialization you could push a new cache object, and then load all the resources that are used throughout the entire game (menu textures and fonts, for example).
Then, when you are loading a new level, you push a new cache object and load all the resource of the level.
When you exit the level, you pop the cache object from the stack, deallocating all level resources, but the menu resources remain intact.
When you exit the game, you pop the last cache object, and all the resources allocated are cleared.

When calling `Vortex.Init`, a cache object is created automatically.

# Function Push:Void()
Pushes a new cache object onto the stack. All resources loaded afterwards are handled by this cache object. When you pop this stack object with the `Cache.Pop` function, all the resources are deallocated.

# Function Pop:Void()
Pops the last pushed cache object from the stack, deallocating all the resources that were loaded after the creation of the cache object.

# Function GetFont:Font(filename:String)
Returns the font with the specified filename, or Null if it could not be found.
If the font has been loaded previously by any cache object, that same object will be returned.
Otherwise, the last pushed cache object will load and return a new font.

# Function GetMesh:Mesh(filename:String, texFilter:Int = Texture.FILTER_TRILINEAR)
Returns the mesh with the specified filename, or Null if it could not be found.
If the mesh has been loaded previously by any cache object, that same object will be returned. Otherwise, the last pushed cache object will load and return a new mesh.

# Function GetTexture:Texture(filename:String, filter:Int = Texture.FILTER_TRILINEAR)
Returns the texture with the specified filename, or Null if the texture was not found.
If the texture has been loaded previously by any cache object, that same object will be returned.
Otherwise, the last pushed cache object will load and return a new texture.




# Class Font

A font is used to render text in Vortex.
It is composed by a texture which contains the characters used to render texts, and a set of glyphs which contains the coordinates of each character within the texture and its offset.
You normally don't generate fonts by hand, but by using the bundled fonttool utility.

# Function Create:Font(filename:String, height:Float, tex:Texture)
Creates a new font, assigning a filename to it, the heigth in pixels of the font, and the texture map that will be used to render texts with this font. After creating it, you should define its glyphs. You normally don't need to use this function, as `Cache.GetFont` gives you a font ready to use.

# Method Free:Void()
When you are not going to render text usign this font anymore, you can call this method to deallocate its resources. If you are using the cache for loading resources, you don't need to call this method, since all cache resources are deallocated when clearing the cache.

# Method GetFilename:String()
Returns the filename of the font.

# Method GetHeight:Float()
Returns the height in pixels of the font.

# Method GetTexture:Texture()
Returns the texture map for this font.

# Method GetTextWidth:Float(text:String)
Returns the width in pixels that the specified text needs to be rendered with the font.

# Method GetTextHeight:Float(text:String)
Returns the width in pixels that the specified text needs to be rendered with the font.

# Method Draw:Void(x:Float, y:Float, text:String)
Draws the specified text at the given x, y screen coordinates.

# Method SetGlyphData:Void(index:Int, x:Float, y:Float, w:Float, h:Float, yoffset:Float)
Sets the rectangle within the font texture where the character with the specified index (it's ASCII code) is located, and the Y offset to render the character relative to the Y drawing coordinate.




# Class Lighting

Vortex supports defining lights sources that can shine on objects.
The maximum number of lights that can be defined simultaneously is 8.
All of these can emit one colored light that can be reflected by objects.

When a light ray hits an object, the color of the light is combined with the color of the object, and that defines the appearance of the object.
This is called *diffuse lighting*.

Also, an object can have a shininess power, which will produce highlights when a light ray hits the objects. This gives the appearance of a shiny object, like a metal surface, and is called *specular lighting*.

Finally, independently from how many light rays are hitting an object, every object also receives some amount of residual lighting, produced by all the lights. This is called *ambient lighting*.
For example, if we are in a sunny open environment, the amount of ambient lighting is much bigger than in a narrow, dark cave, because the intensity of all the lights produce a brighter residual lighting.

Lights can be at infinity, emitting rays in one direction (called *directional lights*; one common example is the sun),
or can be at one specific place, emitting rays in all directions that attenuate with distance (called *point lights*).

# Const NUM_LIGHTS : Int
# Const DIRECTIONAL : Int
# Const POINT : Int

# Function SetLightEnabled:Void(index:Int, enabled:Bool)
Sets whether the light with the specified index (in the range [0,7]) must be taken into account or not when computing lighting.

# Function IsLightEnabled:Bool(index:Int)
Returns whether the specified light is enabled or not.

# Function SetLightType:Void(index:Int, type:Int)
Sets the type of the specified light. It can take one of the following values:

| Value                | Meaning
| Lighting.DIRECTIONAL | A directional light. This light behaves as a light source coming from infinity with the direction specified by a normal vector, and this type of lighting is commonly used to represent the sun light. This is the default value.
| Lighting.POINT       | A point light. This light is placed at a position in the 3D space, and attenuates with distance. The linear attenuation factor can be specified with the `Lighting.SetLightAttenuation` function.

# Function GetLightType:Int(index:Int)
Returns the type of the specified light.

# Function SetLightPosition:Void(index:Int, x:Float, y:Float, z:Float)
Sets the position of the specified light in 3D space. In directional lights, this value is a normal vector that indicates the direction that the light is coming from.

# Function GetLightX:Float(index:Int)
Returns the X position of the specified light.

# Function GetLightY:Float(index:Int)
Returns the Y position of the specified light.

# Function GetLightZ:Float(index:Int)
Returns the Z position of the specified light.

# Function SetLightColor:Void(index:Int, r:Float, g:Float, b:Float)
Sets the color that the specified light emits. White by default (1,1,1).

# Function GetLightRed:Float(index:Int)
Returns the red component of the specified light color.

# Function GetLightGreen:Float(index:Int)
Returns the green component of the specified light color.

# Function GetLightBlue:Float(index:Int)
Returns the blue component of the specified light color.

# Function SetLightAttenuation:Void(index:Int, att:Float)
Sets the attenuation factor of the specified light. This value is ignored for directional lights.

# Function GetLightAttenuation:Float(index:Int)
Returns the attenuation factor of the specified light.

# Function Prepare:Void(ambientRed:Float = 0.3, ambientGreen:Float = 0.3, ambientBlue:Float = 0.3)
Prepares the engine to render with lighting in the next frame, using the color color components specified
as parameters as the ambient color (this is, the lighting that will be received by all geometry independent from the light sources).
Required lights must have been previously enabled and configured. If you do not call this before drawing your scene,
no lighting information will be computed, despite of which lights were enabled.




# Class Mat4

Represents a 4x4 homogeneus coordinate matrix. Transformations in 3D space are defined with these kind of matrices, as well as the projection of 3D graphics to the screen.

To define how graphics are projected to the screen, you can setup a projection matrix with the methods `SetOrtho` (if you want an orthographic projection), `SetPerspective`, or `SetFrustum` (if you want a perspective projection), and set that matrix as the projection matrix with `Renderer.SetProjectionMatrix` before rendering.

To define the viewer's position and orientation, you can use the mdthod 'LookAt', and set that matrix as the view matrix with `Renderer.SetViewMatrix`before rendering.

To define the position, rotation and scale of an object in the 3D world, you can create a transformation matrix with the methods `SetTransform` or `SetBillboardTransform` (if you want to render an object that always faces the viewer, like a billboard), and set that matrix as the model matrix with `Renderer.SetModelMatrix` before rendering.

Not all matrix methods are represented here, only the ones above, which are the relevant ones for most situations:

# Method SetOrtho:Void(left:Float, right:Float, bottom:Float, top:Float, near:Float, far:Float)

# Method SetFrustum:Void(left:Float, right:Float, bottom:Float, top:Float, near:Float, far:Float)

# Method SetPerspective:Void(fovy:Float, aspect:Float, near:Float, far:Float)

# Method LookAt:Void(eyex:Float, eyey:Float, eyez:Float, centerx:Float, centery:Float, centerz:Float, upx:Float, upy:Float, upz:Float)

# Method SetTransform:Void(x:Float, y:Float, z:Float, rw:Float, rx:Float, ry:Float, rz:Float, sx:Float, sy:Float, sz:Float)

# Method SetTransform:Void(x:Float, y:Float, z:Float, rx:Float, ry:Float, rz:Float, sx:Float, sy:Float, sz:Float)

# Method SetBillboardTransform:Void(view:Mat4, x:Float, y:Float, z:Float, spin:Float, width:Float, height:Float, cylindrical:Bool = False)




# Class Material

A material represents the visual information such as diffuse texture, color, or alpha (opacity).
It is used to render objects with a specific appearance.

# Function Create:Material(diffuseTex:Texture = Null)
Create a new material with the specified diffuse texture.

# Method Set:Void(other:Material)
Set the properties of the material to be those of the one passed as parameter.

# Method SetDiffuseColor:Void(r:Float, g:Float, b:Float)
Sets the diffuse color. Geometry is tinted using the diffuse color, and it is also used in lighting calculations. The default value is white (1,1,1).

# Method GetDiffuseRed:Float()
Returns the red component of the diffuse color, in the range 0 .. 1.

# Method GetDiffuseGreen:Float()
Returns the green component of the diffuse color, in the range 0 .. 1.

# Method GetDiffuseBlue:Float()
Returns the blue component of the diffuse color, in the range 0 .. 1.

# Method SetAlpha:Void(alpha:Float)
Sets the alpha (opacity) of the material, with 0 being completely transparent and 1 being completely opaque. The default value is 1.

# Method GetAlpha:Float()
Returns the alpha (opacity) of the material, in the range 0 (transparent) .. 1 (opaque).

# Method SetShininess:Void(shininess:Float)
Sets the specular shininess of the material. A value of 0 will disable specular reflections entirely, whereas a value in the range (0,1] will indicate the strength of the specular reflection.

# Method GetShininess:Float()
Returns the specular shininess of the material.

# Method SetDiffuseTexture:Void(tex:Texture)
Sets the diffuse texture of the material.

# Method GetDiffuseTexture:Texture()
Returns the diffuse texture of the material, or `Null` if there is no diffuse texture.

# Method SetBlendMode:Void(mode:Int)
Sets the blend mode of the material. This defines how the final look of the geometry using this material blends with the background, after computing texture, color and lighting information.

It takes one of the following values:

| Value             | Meaning
| Renderer.BLEND_ALPHA | The computed alpha value of the material (taking into account both material alpha and texture alpha values) is used to blend with the background. This is the default value.
| Renderer.BLEND_ADD   | The computed color of the material is added to the background. This is useful to render "glow" geometry, such as fire and lasers.
| Renderer.BLEND_MUL   | The computed color of the material is multiplied with the background. This is useful to render lightmap geometry on top of other geometry.

# Method GetBlendMode:Int()
Returns the blend mode of the material.

# Method SetCulling:Void(enable:Bool)
Enables or disables backface culling. When it is enabled, internal faces of the geometry using this material will not be rendered. It is enabled by default.

# Method GetCulling:Bool()
Returns whether backface culling is enabled or not.

# Method SetDepthWrite:Void(enable:Bool)
Enabled or disables depth buffer writing. When it is disabled, other geometry further away from the viewer may occlude the geometry that uses this material. It is enabled by default.

# Method GetDepthWrite:Bool()
Returns whether depth buffer writing is enabled or not.

# Method Prepare:Void()
Prepares this material for drawing. All subsequent geometry drawn will use the visual properties of this material. You normally do not need to use this method directly.




# Class Mesh

A mesh is the description of a set of geometry (triangles), materials and optional animations that belong to one object.
For every material that we need, there will be a surface in the mesh containing the geometry to be drawn with that material.
The standard way to draw a mesh on the 3D space is by adding it to a RenderBatch, together with a transformation matrix that defines its position, rotation and scale. A mesh can be added mutiple times to the same RenderBatch, using different transformation matrices.

# Function Create:Mesh()
Creates a new empty mesh. This function is used if we want to generate meshes procedurally.
If you want to load meshes from disk, the the `Cache.GetMesh` function instead.

# Method Free:Void()
When we don't need to use this mesh anymore (for example, if we have removed it from all render batches and will no add it ever again), we can use this function to deallocate its resources.
If the mesh has been created with the function `Cache.GetMesh`, we must not call this method.

# Method GetFilename:String()
Returns the filename assigned to this mesh when it cas created.

# Method SetFilename:Void(filename:String)
Sets the filename of the mesh. This is useful if you are implementing a custom mesh loader and you want to identify the filename that the mesh was created from.

# Method AddSurface:Void(surf:Surface)
Creates a new surface on the mesh and returns its handle.
A surface is a set of geometry that use the same material and it's attached to a same bone (if the mesh is animated).

# Method GetNumSurfaces:Int()
Returns the number of surfaces that this mesh contains.

# Method GetSurface:Surface(index:Int)
Returns a surface contained in the mesh. The value of `index` must be in the range `[0, GetNumSurfaces()-1]`.

# Method SetLastFrame:Void(lastFrame:Int)
Sets the last animation frame for the mesh. You should call this method only if generating an animated mesh procedurally, but not when loading the mesh from disk.

# Method GetLastFrame:Int()
Returns the last animation frame contained in the mesh.

# Method AddBone:Void(bone:Bone)
Adds a new bone to the mesh.

# Method GetNumBones:Int()
Gets the number of bones in the mesh.

# Method GetBone:Bone(index:Int)
Gets the bone at the specified `index`, which is a value between `0` and `GetNumBones`.

# Method FindBone:Bone(name:String)
If a bone with the specified name is found on the mesh, returns it. If not, it returns `Null`.

# Method Animate:Void(animMatrices:Mat4[], frame:Float, firstFrame:Int = 0, lastFrame:Int = 0)
Calculates animation data for the specified frame in the mesh and updates the matrices in `animMatrices` using this data.




# Class RenderBatch

The RenderBatch provides an efficient way of rendering geometry, since it groups the geometry to reduce the number of render calls needed. 3D geometry is rendered in Vortex through a `RenderBatch`. You can add meshes and single surfaces to the batch, together with a transformation matrix that indicates where to draw. The same object can be added multiple times to a batch, in case you want that object to appear at several locations in your scene.

# Function Create:RenderBatch()
Creates and returns a new `RenderBatch`.

# Method AddSurface:Void(surface:Surface, transform:Mat4, overrideMaterial:Material = Null)
Adds a surface to the batch, providing a transformation and an optional material that will be used for rendering instead of the one defined in the surface.

# Method AddSurface:Void(surface:Surface, transform:Mat4, overrideMaterial:Material = Null, animMatrices:Mat4[])
Adds an animated surface to the batch, providing a transformation, an optional material that will be used for rendering instead of the one defined in the surface, and a set of matrices with the bone transformations. You won't normally need to use this function.

# Method RemoveSurface:Void(surface:Surface, transform:Mat4)
Removes from the batch the instance of the surface that was being rendered with the specified transformation matrix.

# Method AddMesh:Void(mesh:Mesh, transform:Mat4)
Adds a static mesh to the batch, providing a transformation.

# Method AddMesh:Void(mesh:Mesh, transform:Mat4, animMatrices:Mat4[])
Adds an animated mesh to the batch, providing a transformation and a set of matrices with the bone transformations.

# Method RemoveMesh:Void(mesh:Mesh, transform:Mat4)
Removes from the batch the instance of the mesh that was being rendered with the specified transformation matrix.

# Method Render:Int()
Renders all the geometry added to this batch, with all the specified transformations.




# Class Renderer

The Renderer is the class used to draw graphics on the screen in immediate mode, and the direct link with the underlying rendering API (OpenGL). For most stuff, you do not need to deal with this class directly, but for example if you want to draw your 2D graphics above the 3D scene, after drawing all your 3D geometry, you must call `Painter.Setup2D` to setup the context for 2D drawing, and then perform your drawing operations.

# Function Setup2D:Void(x:Int, y:Int, width:Int, height:Int)
Setup the context for 2D painting. The parameters define the rectangle within the screen where drawing will take place. You must call this function before doing any 2D drawing.

# Function Setup3D:Void(x:Int, y:Int, width:Int, height:Int)
Setup the context for 3D painting. The parameters define the rectangle within the screen where drawing will take place.
You must call this function before rendering a `RenderBatch' that contains geometry to render in 3D space.

# Function SetProjectionMatrix:Void(m:Mat4)
Setup the projection matrix. You must call this function before rendering any 2D graphics.

# Function GetProjectionMatrix:Mat4()
Returns the currently active projection matrix.

# Function SetViewMatrix:Void(m:Mat4)
Setup the view matrix.
You must call this function before rendering a `RenderBatch' that contains geometry to render in 3D space.

# Function GetViewMatrix:Mat4()
Returns the currently active view matrix.

# Function SetModelMatrix:Void(m:Mat4)
Setup the model matrix. You don't normally need to call this function, because a `RenderBatch`sets the correct model matriz before rendering each batch of geometry.

# Function GetModelMatrix:Mat4()
Returns the currently active model matrix.

# Function SetBlendMode:Void(mode:Int)
Sets the blend mode to use when painting. Possible values are:

| Value       | Meaning
| Renderer.BLEND_ALPHA | The computed alpha value (taking into account both opacity and texture alpha values) is used to blend with the background. This is the default value.
| Renderer.BLEND_ADD   | The computed color is added to the background. This is useful to render "glow" geometry, such as fire and lasers.
| Renderer.BLEND_MUL   | The computed color is multiplied with the background. This is useful to render lightmap geometry on top of other geometry.

# Function SetColor:Void(r:Float, g:Float, b:Float, a:Float = 1)
Sets the drawing color.

# Function ClearColorBuffer:Void(r:Float = 0, g:Float = 0, b:Float = 0)
Clears the background (actually, the boundaries defined when the call to `Renderer.Setup2D` or `Renderer.Setup3D` was made) with the specified color.

# Function DrawPoint:Void(x:Float, y:Float, z:Float)
Draws a point at the specified coordinates. For 2D graphics, `z` should be 0.

# Function DrawLine:Void(x1:Float, y1:Float, z1:Float, x2:Float, y2:Float, z2:Float)
Draws a line that goes from x1, y1 to x2, y2. For 2D graphics, both `z1` and `z2` should be 0.

# Function DrawRect:Void(x:Float, y:Float, z:Float, width:Float, height:Float)
Draws a filled rectangle at the specified coordinates, with the given width and height. For 2D graphics, `z` should be 0.

# Function DrawEllipse:Void(x:Float, y:Float, z:Float, width:Float, height:Float)
Draw a filled ellipse at the specified coordinates, with the given width and height. For 2D graphics, `z` should be 0.




# Class Surface

The surface class contains a set of geometry (vertices and indices that form triangles) and a material to draw that geometry.

# Function Create:Surface(material:Material = Null)
Creates a new surface. If a material is passed, it will be copied. If not, a new material will be created for the surface.

# Method Free:Void()
Deallocates all the resources used by this surface. You don't normally need to call this method directly, since meshes call this method on all their surfaces when the mesh itself is freed.

# Method Set:Void(other:Surface)
Sets this surface's material and geometry data to copy those of the mesh passed as parameter. The surface is automatically rebuilt.

# Method GetMaterial:Material()
Returns the material that this surface uses.

# Method AddTriangle:Int(v0:Int, v1:Int, v2:Int)
Adds a new triangle to the surface. A triangle contains three indices, that reference the vertices in the surface. Returns the index of the triangle within the surface.

# Method GetNumTriangles:Int()
Returns the number of triangles in the surface.

# Method SetTriangleVertices:Void(index:Int, v0:Int, v1:Int, v2:Int)
Changes the vertex indices used by a specified triangle.

# Method GetTriangleV0:Int(index:Int)
Returns the index of the first vertex in the specified triangle.

# Method GetTriangleV1:Int(index:Int)
Returns the index of the second vertex in the specified triangle.

# Method GetTriangleV2:Int(index:Int)
Returns the index of the third vertex in the specified triangle.

# Method AddVertex:Int(x:Float, y:Float, z:Float, nx:Float, ny:Float, nz:Float, r:Float, g:Float, b:Float, a:Float, u:Float, v:Float)
Adds a new vertex to the surface, with the given position, normal, color, and texture coordinates. Returns the index of the vertex within the surface.

# Method GetNumVertices:Int()
Returns the number of vertices in the surface.

# Method SetVertexPosition:Void(index:Int, x:Float, y:Float, z:Float)
Sets the position of the specified vertex.

# Method SetVertexNormal:Void(index:Int, nx:Float, ny:Float, nz:Float)
Sets the normal vector of the specified vertex.

# Method SetVertexColor:Void(index:Int, r:Float, g:Float, b:Float, a:Float)
Sets the color of the specified vertex.

# Method SetVertexTexCoords:Void(index:Int, u:Float, v:Float)
Sets the texture coordinates of the specified vertex.

# Method SetVertexBone:Void(vertex:Int, index:Int, bone:Int, weight:Float)
Sets one of the bones that the vertex is attached to, and the weight that the bone has on the vertex (between 0 and 1).
A vertex can be attached to a maximum of four bones, specified in the `index` parameter with a value between 0 and 3.
Bone is the index within the mesh of the specified bone.

# Method GetVertexX:Float(index:Int)
Returns the X position of the specified vertex.

# Method GetVertexY:Float(index:Int)
Returns the Y position of the specified vertex.

# Method GetVertexZ:Float(index:Int)
Returns the Z position of the specified vertex.

# Method GetVertexNX:Float(index:Int)
Returns the X component of the normal of the specified vertex.

# Method GetVertexNY:Float(index:Int)
Returns the Y component of the normal of the specified vertex.

# Method GetVertexNZ:Float(index:Int)
Returns the Z component of the normal of the specified vertex.

# Method GetVertexRed:Float(index:Int)
Returns the red component of the color of the specified vertex.

# Method GetVertexGreen:Float(index:Int)
Returns the green component of the color of the specified vertex.

# Method GetVertexBlue:Float(index:Int)
Returns the blue component of the color of the specified vertex.

# Method GetVertexAlpha:Float(index:Int)
Returns the alpha (opacity) of the specified vertex.

# Method GetVertexU:Float(index:Int)
Returns the U texture coordinate of the specified vertex.

# Method GetVertexV:Float(index:Int)
Returns the V texture coordinate of the specified vertex.

# Method GetVertexBoneIndex:Int(vertex:Int, index:Int)
Returns the specified vertex bone index.

# Method GetVertexBoneWeight:Float(vertex:Int, index:Int)
Return the specified vertex bone weight.

# Method Rebuild:Void()
Rebuilds the internal representation of the geometry in the surface.
To increase rendering performance, Vortex holds a copy of the data of all surfaces in video memory, so whenever you make a change to the geometry of a surface, you must call this function so the video memory is updated.

# Method Draw:Void()
Draws the surface. You don't normally need to call this function, because you will draw surfaces through a `RenderBatch`.




# Class Texture

A texture represents a buffer in video memory that contains pixel data.
Textures can be contained in materials and applied to objects together with other information like color and opacity, or drawn to the screen directly (for example to render 2D sprites).

# Function Create:Texture(filename:String, filter:Int)
Loads a texture from disk.
We must also specify one of the following filtering modes:

* Renderer.FILTER_NONE
* Renderer.FILTER_LINEAR
* Renderer.FILTER_BILINEAR
* Renderer.FILTER_TRILINEAR

You won't normally use this function directly, because textures can be obtained from image files using the `Cache.GetTexture` function.

# Function Create:Texture(buffer:DataBuffer, width:Int, height:Int, filter:Int)
Creates a new texture. Its pixel data will be generated from the passed memory `buffer`, with the specified `width` and `height`.
We must also specify one of the following filtering modes:

* Renderer.FILTER_NONE
* Renderer.FILTER_LINEAR
* Renderer.FILTER_BILINEAR
* Renderer.FILTER_TRILINEAR

You won't normally use this function directly, because textures can be obtained from image files using the `Cache.GetTexture` function.

# Method Free:Void()
Frees the resources used by this texture.
If you created the texture with the `Cache.GetTexture` function, then you must not call this function.
If you created the texture with `Texture.Create`, then you must call this function when you no longer need the texture.

# Method GetFilename:String()
Returns the filename that this texture was created from.

# Method GetHandle:Int()
Returns the internal handle of this texture. This is an identifier in video memory, and you don't normally need to use this value.

# Method GetWidth:Int()
Returns the width, in pixels, of the texture.

# Method GetHeight:Int()
Returns the height, in pixels, of the texture.

# Method Draw:Void(x:Float, y:Float, width:Float = 0, height:Float = 0, rectx:Float = 0, recty:Float = 0, rectwidth:Float = 0, rectheight:Float = 0)
Draws the texture to the specified screen coordinates.
You can also specifY a width and a height different than its original size, and a rectangle within the texture to draw instead of the whole thing.




# Class Vortex

This class contains some global general porpose functions to setup the library and get status information.

# Function Init:Bool()
Initializes the Vortex library. This should be called before any other function in the library.

# Function GetShaderError:String()
Reports any errors that took place while compiling the shaders on initialization.

# Function GetAPIVersion:Float()
Get the version of the API supported by this machine (currently, the version of OpenGL supported by the implementation).

# Function GetShadingVersion:Float()
Get the version of the shading language supported by this machine (currently, the version of GLSL supported by the implementation).
