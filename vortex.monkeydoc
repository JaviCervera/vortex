# Module vortex

The Vortex module adds a very simple 3D rendering engine based on OpenGL ES 2.
More than a full 3D engine, it provides a lower-level API, similar to what the official Mojo offers for 2D.

>>> Coordinate systems and rotations
The handedness of the coordinate system can be selected when using Vortex.
To do that, you can write this at the beginning of your program:

`Import vortex.src.config`~n
`#VORTEX_HANDEDNESS=Mode`

Where `Mode` can be one of:
| Mode        | Description
| VORTEX_LH   | Left handed coordinate system where X points right, Y points up, and Z points away from the viewer. This is the convention in Direct3D, and the default mode in Vortex.
| VORTEX_RH_Y | Right handed coordinate system where X points right, Y points up, and Z points towards the viewer. This is the convention in OpenGL.
| VORTEX_RH_Z | Right handed coordinate system, where X points right, Y points away from the viewer, and Z points up. This was the default mode in previous versions of Vortex.

Rotations can be expressed both using quaternions and euler angles (expressed in degrees).

>>> Screen coordinates
The vertical direction of the screen can be selected when using Vortex.
To do that, you can write this at the beginning of your program:

`Import vortex.src.config`~n
`#VORTEX_SCREENCOORDS=Mode`

Where 'Mode' can be one of:
| Mode          | Description
| VORTEX_YDOWN  | Coordinates 0,0 represent the top left corner of the screen, while coordinates DeviceWidth(), DeviceHeight() represent the bottom right. This is common in several graphics libraries (like Mojo), and the default in Vortex.
| VORTEX_YUP    | Coordinates 0,0 represent the bottom left corner of the screen, while coordinates DeviceWidth(), DeviceHeight() represent the top right. This is a standard in math to define the Euclidean plane.

>>> Texture coordinates
On left handed coordinate systems, texture coordinates are mapped from the top left (coordinates 0,0) to the bottom right (coordinates 1,1).~n
On right handed coordinate systems, texture coordinates are mapped from the bottom left (coordinates 0,0) to the top right (coordinates 1,1).

>>> Triangle order
On left handed coordinate systems, front facing triangles are those that are mapped to the screen in clockwise order.~n
On right handed coordinate systems, front facing triangles are those that are mapped to the screen in counter clockwise order.~n
Back facing triangles are by default occluded by Vortex.

>>> Concepts
Here we will explain the general concepts of the library, starting with the most fundamental concepts, and detailing later more specific and specialized elements.

>>>> Drawable
A drawable represents a visible object that can be rendered in a position of 3D space, with an specific rotation and scale.
Examples of drawables are the following:
* A 3D object (called a mesh), which can be static or animated, and can contain one or more surfaces (a surface is a set of geometry that uses the same brush -texture, color...-).
* A single surface.
* A plain billboard that always faces the camera.
---
>>>> Viewer
A viewer is an observer of the 3D world.
It has a position and rotation in 3D space, a rectangle in the screen to draw to, as well as other parameters.
In a single player game, you should have at least one viewer representing what the player sees on the entire screen.
In a split screen multiplayer game, you will have one viewer per player, each drawing to a different rectangle of the screen.

The default way to render 3D objects in Vortex is by placing objects using drawables, and drawing to the screen with the data specified by one or more viewers.
---
>>>> Lighting
Vortex supports defining lights sources that can shine on objects.
The maximum number of lights that can be defined simultaneously is 8.
All of these can emit one colored light that can be reflected by objects.

When a light ray hits an object, the color of the light is combined with the color of the object, and that defines the appearance of the object.
This is called *diffuse lighting*.

Also, an object can have a shininess power, which will produce highlights when a light ray hits the objects. This gives the appearance of a shiny object, like a metal surface, and is called *specular lighting*.

Finally, independently from how many light rays are hitting an object, every object also receives some amount of residual lighting, produced by all the lights. This is called *ambient lighting*.
For example, if we are in a sunny open environment, the amount of ambient lighting is much bigger than in a narrow, dark cave, because the intensity of all the lights produce a brighter residual lighting.

Lights can be at infinity, emitting rays in one direction (called *directional lights*; one common example is the sun),
or can be at one specific place, emitting rays in all directions that attenuate with distance (called *point lights*).
---
>>>> Texture
A texture represents a buffer in video memory that contains pixel data.
Textures can be contained in brushes and applied to objects together with other information like color and opacity, or drawn to the screen directly (for example to render 2D sprites).
---
>>>> Brush
A brush represents material with visual information such as base texture, color, or opacity.
It is used to render objects with a specific appearance.
---
>>>> Mesh
A mesh is the description of a set of geometry (triangles), brushes and optional animations that belong to one object.
For every brush that we need, there will be a surface in the mesh containing the geometry to be drawn with that brush.
The standard way to draw a mesh on the 3D space is by creating a Drawable from this mesh, and giving it a position, rotation and scale. Several drawables can be created from the same mesh.
---
>>>> Surface
The surface class contains a set of geometry (vertices and indices that form triangles) and a brush to draw that geometry.
---
>>>> Bone
A bone contains a list of transformations to be applied to the geometry attached to it when using animations. Meshes can contains bones that animate the surfaces of the mesh (to make it walk, for example).
---
>>>> Font
A font is used to render text in Vortex.
It is composed by a texture which contains the characters used to render texts, and a set of glyphs which contains the coordinates of each character within the texture and its offset.
You normally don't generate fonts by hand, but by using the bundled fonttool utility.
---
>>>> Cache
The cache is used to avoid loading resources from disk more that once.
When you want to load a resource from disk (a texture, a mesh, or a font), Vortex will check if the resource was already loaded, in which case the same instance is returned to you, so it is not loaded multiple times in memory.

Internally, Vortex holds a stack of cache objects. You can add a new cache with the `Cache_Push` function, and all the resources loaded afterwards will be deallocated when the cache object is removed from the stack with `Cache_Pop`.
For example, on game initialization you could push a new cache object, and then load all the resources that are used throughout the entire game (menu textures and fonts, for example).
Then, when you are loading a new level, you push a new cache object and load all the resource of the level.
When you exit the level, you pop the cache object from the stack, deallocating all level resources, but the menu resources remain intact.
When you exit the game, you pop the last cache object, and all the resources allocated are cleared.

Upon initialization, Vortex always creates one cache object automatically.
---
>>>> Painter
The Painter is used to draw 2D graphics on the screen. If you want to draw your 2D graphics above the 3D scene, after drawing all your 3D geometry, you must call Painter_Setup2D to setup the context for 2D drawing, and then perform your drawing operations.




# Function Bone_Create:Object(name:String)
Creates a new bone with the specified name.

# Function Bone_GetName:String(bone:Object)
Returns the name of the bone.

# Function Bone_SetParent:Void(bone:Object, parent:Object)
Sets the parent of the bone.

# Function Bone_GetParent:Object(bone:Object)
Returns the parent of the bone, which will be another bone, or Null if it is the root bone in the mesh.

# Function Bone_CalcPoseMatrix:Void(bone:Object, px:Float, py:Float, pz:Float, rw:Float, rx:Float, ry:Float, rz:Float, sx:Float, sy:Float, sz:Float)
Sets the position, rotation (as a quaternion) and scale, relative to its parent, to be applied to the bone when it is not being rendered animated.
Although the parameters you pass here are relative to its parent, the generated matrix contains the globals transformation, so the parent's pose matrix must have been previously defined.
You don't need to use this function, unless you are generating meshes by hand. When loading a mesh from disk, this function will be called automatically by the loader.

# Function Bone_GetPoseMatrix:Float[](bone:Object)
Returns a 16 float array that contains the global pose transform matrix.
You don't normally need to call this function.
It is used internally when rendering the geometry attached to the bone.

# Function Bone_GetInversePoseMatrix:Float[](bone:Object)
Returns a 16 float array that contains the inverse of the global pose transform matrix.
You don't normally need to call this function.
It is used internally when rendering the geometry attached to the bone.

# Function Bone_AddSurface:Void(bone:Object, surf:Object)
Adds a new surface to the bone. Surfaces attached to a bone contain geometry that is rendered with the transformation defined by the bone.
You don't need to use this function, unless you are generating meshes by hand. When loading a mesh from disk, this function will be called automatically by the loader.

# Function Bone_GetNumSurfaces:Int(bone:Object)
Returns the number of surfaces attached to the bone.

# Function Bone_GetSurface:Object(bone:Object, index:Int)
Returns the specified surface attached to the bone. The value of `index` goes in the range `0 .. Bone_GetNumSurfaces(bone) - 1`.

# Function Bone_AddPositionKey:Void(bone:Object, keyframe:Int, x:Float, y:Float, z:Float)
Adds a new position transformation to the bone at the specified keyframe.

# Function Bone_AddRotationKey:Void(bone:Object, keyframe:Int, w:Float, x:Float, y:Float, z:Float)
Adds a new rotation quaternion to the bone at the specified keyframe.

# Function Bone_AddScaleKey:Void(bone:Object, keyframe:Int, x:Float, y:Float, z:Float)
Adds a new scale transformation to the bone at the specified keyframe.

# Function Bone_GetNumPositionKeys:Int(bone:Object)
Returns the number of position keyframes in the bone.

# Function Bone_GetPositionKeyFrame:Int(bone:Object, index:Int)
Returns the frame number of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Function Bone_GetPositionKeyX:Float(bone:Object, index:Int)
Returns the X coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Function Bone_GetPositionKeyY:Float(bone:Object, index:Int)
Returns the Y coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Function Bone_GetPositionKeyZ:Float(bone:Object, index:Int)
Returns the Z coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Function Bone_GetNumRotationKeys:Int(bone:Object)
Returns the number of rotation keyframes in the bone.

# Function Bone_GetRotationKeyFrame:Int(bone:Object, index:Int)
Returns the frame number of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Function Bone_GetRotationKeyW:Float(bone:Object, index:Int)
Returns the W quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Function Bone_GetRotationKeyX:Float(bone:Object, index:Int)
Returns the X quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Function Bone_GetRotationKeyY:Float(bone:Object, index:Int)
Returns the Y quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Function Bone_GetRotationKeyZ:Float(bone:Object, index:Int)
Returns the Z quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Function Bone_GetNumScaleKeys:Int(bone:Object)
Returns the number of scale keyframes in the bone.

# Function Bone_GetScaleKeyFrame:Int(bone:Object, index:Int)
Returns the frame number of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Function Bone_GetScaleKeyX:Float(bone:Object, index:Int)
Returns the X coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Function Bone_GetScaleKeyY:Float(bone:Object, index:Int)
Returns the Y coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Function Bone_GetScaleKeyZ:Float(bone:Object, index:Int)
Returns the Z coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.




# Function Brush_SetBaseColor:Void(brush:Object, r:Float, g:Float, b:Float)
Sets the base color. Geometry is tinted using the base color, and it is also used as the diffuse component of the geometry using this brush in lighting calculations. The default value is white (1,1,1).

# Function Brush_GetRed:Float(brush:Object)
Returns the red component of the base color, in the range 0 .. 1.

# Function Brush_GetGreen:Float(brush:Object)
Returns the green component of the base color, in the range 0 .. 1.

# Function Brush_GetBlue:Float(brush:Object)
Returns the blue component of the base color, in the range 0 .. 1.

# Function Brush_SetOpacity:Void(brush:Object)
Sets the opacity of the brush, with 0 being completely transparent and 1 being completely opaque. The default value is 1.

# Function Brush_GetOpacity:Float(brush:Object)
Returns the opacity of the brush, in the range 0 (transparent) .. 1 (opaque).

# Function Brush_SetShininess:Void(brush:Object, shininess:Float)
Sets the specular shininess of the brush. A value of 0 will disable specular reflections entirely, whereas a value in the range (0,1] will indicate the strength of the specular reflection.

# Function Brush_GetShininess:Float(brush:Object)
Returns the specular shininess of the brush.

# Function Brush_SetBaseTexture:Void(brush:Object, tex:Object)
Sets the base texture of the brush.

# Function Brush_GetBaseTexture:Object(brush:Object)
Returns the base texture of the brush, or Null if there is no base texture.

# Function Brush_SetBlendMode:Void(brush:Object, mode:Int)
Sets the blend mode of the brush. This defines how the final look of the geometry using this brush blends with the background, after computing texture, color and lighting information.

It takes one of the following values:

| Value             | Meaning
| BLEND_ALPHA | The computed alpha value of the brush (taking into account both brush opacity and texture alpha values) is used to blend with the background. This is the default value.
| BLEND_ADD   | The computed color of the brush is added to the background. This is useful to render "glow" geometry, such as fire and lasers.
| BLEND_MUL   | The computed color of the brush is multiplied with the background. This is useful to render lightmap geometry on top of other geometry.

# Function Brush_GetBlendMode:Int(brush:Object)
Returns the blend mode of the brush.

# Function Brush_SetCulling:Void(brush:Object, enable:Bool)
Enables or disables backface culling. When it is enabled, internal faces of the geometry using this brush will not be rendered. It is enabled by default.

# Function Brush_GetCulling:Bool(brush:Object)
Returns whether backface culling is enabled or not.

# Function Brush_SetDepthWrite:Void(brush:Object, enable:Bool)
Enabled or disables depth buffer writing. When it is disabled, other geometry further away from the viewer may occlude the geometry that uses this brush. It is enabled by default.

# Function Brush_GetDepthWrite:Bool(brush:Object)
Returns whether depth buffer writing is enabled or not.

# Function Brush_Prepare:Void(brush:Object)
Prepares this brush for drawing. All subsequent geometry drawn will use the visual properties of this brush. You normally do not need to use this method directly, it is used internally by `Drawable_Draw()`.




# Function Cache_Push:Void()
Pushes a new cache object onto the stack. All resources loaded afterwards are handled by this cache object. When you pop this stack object with the Cache_Pop function, all the resources are deallocated.

# Function Cache_Pop:Void()
Pops the last pushed cache object from the stack, deallocating all the resources that were loaded after the creation of the cache object.




# Function Drawable_Create:Object()
Creates a new drawable with an empty surface.
You can add indices and vertices to this surface and call `Surface_Rebuild()` to regenerate internal buffers.
After you call `Drawable_Free()` on this drawable, the surface will be automatically freed.

# Function Drawable_CreateWithMesh:Object(mesh:Object)
Creates a new drawable that renders a mesh.

# Function Drawable_CreateBillboard:Object(texture:Object, width:Float, height:Float, mode:Int)
Creates a new drawable that renders a billboard.
We must specify a texture that will define how the billboard looks.
We can specify a custom with and height or leave these values at 0 to use the texture size.

The `mode` parameter indicates how the billboard is oriented to face the viewer, and can take one of the following values:

| Value                  | Meaning
| BILLBOARD_SPHERICAL    | The billboard's X and Y (or Z when using a right-handed coordinate system) axes are oriented to face the viewer.
| BILLBOARD_CYLINDRICAL  | The billboard's Y (or Z when using a right-handed coordinate system) axis is oriented to face the viewer.

# Function Drawable_Free:Void(drawable:Object)
When a drawable is no longer going to be used, we must use this method to deallocate the resources that it uses.

# Function Drawable_Animate:Void(drawable:Object, frame:Float, firstFrame:Int = 0, lastFrame:Int = 0)
Updates the internal animation matrices so hold the animation data for the specified `frame`. We can indicate the first and last frames in the animation sequence if the mesh contains frames for several animations (for example: walk, jump, shoot, etc).

# Function Drawable_Draw:Void(drawable:Object, animated:Bool = False)
Renders a drawable with its current transformation in the 3D space (position, rotation and scale).
If the drawable contains an animated mesh, we can indicate whether we want to draw the mesh static or animated.

# Function Drawable_GetBillboardMode:Int(drawable:Object)
Returns the billboarding mode that this drawable has, or BILLBOARD_NONE if the drawable is not a billboard.

# Function Drawable_GetMesh:Object(drawable:Object)
Returns the mesh attached to this billboard, or Null if there is none.

# Function Drawable_GetSurface:Object(drawable:Object)
Returns the surface attached to this billboard, or Null if there is none.

# Function Drawable_SetPosition:Void(drawable:Object, x:Float, y:Float, z:Float)
Set the position of the drawable in 3D space.

# Function Drawable_GetX:Float(drawable:Object)
Returns the X position of the drawable in 3D space.

# Function Drawable_GetY:Float(drawable:Object)
Returns the Y position of the drawable in 3D space.

# Function Drawable_GetZ:Float(drawable:Object)
Returns the Z position of the drawable in 3D space.

# Function Drawable_SetEuler:Void(drawable:Object, x:Float, y:Float, z:Float)
Sets the rotation of the drawable, specified as an euler rotation around its XYZ axes.

# Function Drawable_GetEulerX:Float(drawable:Object)
Returns the euler rotation of the drawable around its X axis.

# Function Drawable_GetEulerY:Float(drawable:Object)
Returns the euler rotation of the drawable around its Y axis.

# Function Drawable_GetEulerZ:Float(drawable:Object)
Returns the euler rotation of the drawable around its Z axis.

# Function Drawable_SetQuat:Void(drawable:Object, w:Float, x:Float, y:Float, z:Float)
Sets the rotation of the drawable, specified as a quaternion.

# Function Drawable_GetQuatW:Float(drawable:Object)
Returns the W component of the quaternion rotation of the drawable.

# Function Drawable_GetQuatX:Float(drawable:Object)
Returns the X component of the quaternion rotation of the drawable.

# Function Drawable_GetQuatY:Float(drawable:Object)
Returns the Y component of the quaternion rotation of the drawable.

# Function Drawable_GetQuatZ:Float(drawable:Object)
Returns the Z component of the quaternion rotation of the drawable.

# Function Drawable_SetScale:Void(drawable:Object, x:Float, y:Float, z:Float)
Sets the scale factor of the drawable, with 1,1,1 being its original size, 2,2,2 being twice its original size, etc.

# Function Drawable_GetScaleX:Float(drawable:Object)
Returns the X scale factor of the drawable.

# Function Drawable_GetScaleY:Float(drawable:Object)
Returns the Y scale factor of the drawable.

# Function Drawable_GetScaleZ:Float(drawable:Object)
Returns the X scale factor of the drawable.

# Function Drawable_Move:Void(drawable:Object, x:Float, y:Float, z:Float)
Translates the drawable from its current position the amount of points specified by the parameters, taking into account the current rotation of the drawable.
For example, Drawable_Move(drawable, 0, 0, 1) will move the drawable 1 point in the direction that it is facing (or upwards when using a right handed coordinate system).




# Function Font_Cache:Object(filename:String)
Returns the font with the specified filename, or Null if it could not be found.
If the font has been loaded previously by any cache object, that same object will be returned.
Otherwise, the last pushed cache object will load and return a new font.

# Function Font_GetFilename:String(font:Object)
Returns the filename of the font.

# Function Font_GetHeight:Float(font:Object)
Returns the height in pixels of the font.

# Function Font_GetTextWidth:Float(font:Object, text:String)
Returns the width in pixels that the specified text needs to be rendered with the font.

# Function Font_GetTextHeight:Float(font:Object, text:String)
Returns the width in pixels that the specified text needs to be rendered with the font.

# Function Font_Draw:Void(font:Object, x:Float, y:Float, text:String)
Draws the specified text at the x, y screen coordinates.




# Function Lighting_SetLightEnabled:Void(index:Int, enabled:Bool)
Sets whether the light with the specified index (in the range [0,7]) must be taken into account or not when computing lighting.

# Function Lighting_IsLightEnabled:Bool(index:Int)
Returns whether the specified light is enabled or not.

# Function Lighting_SetLightType:Void(index:Int, type:Int)
Sets the type of the specified light. It can take one of the following values:

| Value             | Meaning
| LIGHT_DIRECTIONAL | A directional light. This light behaves as a light source coming from infinity with the direction specified by a normal vector, and this type of lighting is commonly used to represent the sun light. This is the default value.
| LIGHT_POINT       | A point light. This light is placed at a position in the 3D space, and attenuates with distance. The linear attenuation factor can be specified with the Lighting_SetLightAttenuation function.

# Function Lighting_GetLightType:Int(index:Int)
Returns the type of the specified light.

# Function Lighting_SetLightPosition:Void(index:Int, x:Float, y:Float, z:Float)
Sets the position of the specified light in 3D space. In directional lights, this value is a normal vector that indicates the direction that the light is coming from.

# Function Lighting_GetLightX:Float(index:Int)
Returns the X position of the specified light.

# Function Lighting_GetLightY:Float(index:Int)
Returns the Y position of the specified light.

# Function Lighting_GetLightZ:Float(index:Int)
Returns the Z position of the specified light.

# Function Lighting_SetLightColor:Void(index:Int, r:Float, g:Float, b:Float)
Sets the color that the specified light emits. White by default (1,1,1).

# Function Lighting_GetLightRed:Float(index:Int)
Returns the red component of the specified light color.

# Function Lighting_GetLightGreen:Float(index:Int)
Returns the green component of the specified light color.

# Function Lighting_GetLightBlue:Float(index:Int)
Returns the blue component of the specified light color.

# Function Lighting_SetLightAttenuation:Void(index:Int, att:Float)
Sets the attenuation factor of the specified light. This value is ignored for directional lights.

# Function Lighting_GetLightAttenuation:Float(index:Int)
Returns the attenuation factor of the specified light.

# Function Lighting_Prepare:Void(ambientRed:Float = 0.3, ambientGreen:Float = 0.3, ambientBlue:Float = 0.3)
Prepares the engine to render with lighting in the next frame, using the color color components specified
as parameters as the ambient color (this is, the lighting that will be received by all geometry independent from the light sources).
Required lights must have been previously enabled and configured. If you do not call this before drawing your scene,
no lighting information will be computed, despite of which lights were enabled.




# Function Mesh_Cache:Object(filename:String, textureFilter:Int = FILTER_TRILINEAR)
Returns the mesh with the specified filename, or Null if it could not be found.
If the mesh has been loaded previously by any cache object, that same object will be returned. Otherwise, the last pushed cache object will load and return a new mesh.

# Function Mesh_Create:Object()
Creates a new empty mesh. This function is used if we want to generate meshes procedurally.
You must indicate whether the mesh is skinned (it has bone weights information for animation) or not.
If you want to load meshes from disk, the the `Mesh_Cache` function instead.

# Function Mesh_Free:Void(mesh:Object)
When we don't need to use this mesh anymore (for example, if there are no more drawables that use it and we do not plan to create new ones), we can use this function to deallocate its resources.
If the mesh has been created with `Mesh_Cache()`, we must not call this method.

# Function Mesh_GetFilename:String(mesh:Object)
Returns the filename assigned to this mesh when it cas created.

# Function Mesh_SetFilename:Void(mesh:Object, filename:String)
Sets the filename of the mesh. This is useful if you are implementing a custom mesh loader and you want to identify the filename that the mesh was created from.

# Function Mesh_AddSurface:Object(mesh:Object)
Creates a new surface on the mesh and returns its handle.
A surface is a set of geometry that use the same brush and it's attached to a same bone (if the mesh is animated).

# Function Mesh_GetNumSurfaces:Int(mesh:Object)
Returns the number of surfaces that this mesh contains.

# Function Mesh_GetSurface:Object(mesh:Object, index:Int)
Returns a surface contained in the mesh. The value of `index` must be in the range `[0, Mesh_GetNumSurfaces(mesh)-1]`.

# Function Mesh_GetLastFrame:Int(mesh:Object)
Returns the last animation frame contained in the mesh.

# Function Mesh_AddBone:Void(mesh:Object, bone:Object)
Adds a new bone to the mesh.

# Function Mesh_GetNumBones:Int(mesh:Object)
Gets the number of bones in the mesh.

# Function Mesh_GetBone:Object(mesh:Object, index:Int)
Gets the bone at the specified `index`, which is a value between `0` and `Mesh_GetNumBones`.

# Function Mesh_FindBone:Object(mesh:Object, name:String)
If a bone with the specified name is found on the mesh, returns it. If not, it returns `Null`.




# Function Painter_Setup2D:Void(x:Int, y:Int, width:Int, height:Int)
Setup the context for 2D painting. The parameters define the rectangle within the screen where drawing will take place. You must call this function before doing any 2D drawing.

# Function Painter_Setup3D:Void(x:Int, y:Int, width:Int, height:Int)
Setup the context for 3D painting. The parameters define the rectangle within the screen where drawing will take place.
You must call this function if you want to draw 3D geometry using `Mesh_Draw` and `Surface_Draw`.
If you are going to render geometry using viewers and drawables (the usual thing), then you don't need to call this function.

# Function Painter_SetProjectionMatrix:Void(m:Float[])
Setup the projection matrix. The parameter must be a float array with 16 values, sorted in column major order.
You must call this function if you want to draw 3D geometry using `Mesh_Draw` and `Surface_Draw`.
If you are going to render geometry using viewers and drawables (the usual thing), then you don't need to call this function.

# Function Painter_GetProjectionMatrix:Void(m:Float[])
Fills the specified 16 elements float array with the currently active projection matrix.

# Function Painter_SetViewMatrix:Void(m:Float[])
Setup the view matrix. The parameter must be a float array with 16 values, sorted in column major order.
You must call this function if you want to draw 3D geometry using `Mesh_Draw` and `Surface_Draw`.
If you are going to render geometry using viewers and drawables (the usual thing), then you don't need to call this function.

# Function Painter_GetViewMatrix:Void(m:Float[])
Fills the specified 16 elements float array with the currently active view matrix.

# Function Painter_SetModelMatrix:Void(m:Float[])
Setup the model matrix. The parameter must be a float array with 16 values, sorted in column major order.
You must call this function if you want to draw 3D geometry using `Mesh_Draw` and `Surface_Draw`.
If you are going to render geometry using viewers and drawables (the usual thing), then you don't need to call this function.

# Function Painter_GetModelMatrix:Void(m:Float[])
Fills the specified 16 elements float array with the currently active model matrix.

# Function Painter_SetBlendMode:Void(mode:Int)
Sets the blend mode to use when painting. Possible values are:

| Value       | Meaning
| BLEND_ALPHA | The computed alpha value (taking into account both opacity and texture alpha values) is used to blend with the background. This is the default value.
| BLEND_ADD   | The computed color is added to the background. This is useful to render "glow" geometry, such as fire and lasers.
| BLEND_MUL   | The computed color is multiplied with the background. This is useful to render lightmap geometry on top of other geometry.

# Function Painter_SetColor:Void(r:Float, g:Float, b:Float, opacity:Float = 1)
Sets the drawing color.

# Function Painter_Cls:Void(r:Float = 0, g:Float = 0, b:Float = 0)
Clears the background (actually, the boundaries defined when the call to `Painter_Setup2D` or `Painter_Setup3D` was made) with the specified color.

# Function Painter_PaintPoint:Void(x:Float, y:Float)
Draws a point at the specified coordinates.

# Function Painter_PaintLine:Void(x1:Float, y1:Float, x2:Float, y2:Float)
Draws a line that goes from x1, y1 to x2, y2.

# Function Painter_PaintRect:Void(x:Float, y:Float, width:Float, height:Float)
Draws a filled rectangle at the specified coordinates, with the given width and height.

# Function Painter_PaintEllipse:Void(x:Float, y:Float, width:Float, height:Float)
Draw a filled ellipse at the specified coordinates, with the given width and height.

# Function Surface_GetBrush:Object(surface:Object)
Returns the brush that this surface uses.

# Function Surface_AddTriangle:Int(surface:Object, v0:Int, v1:Int, v2:Int)
Adds a new triangle to the surface. A triangle contains three indices, that reference the vertices in the surface. Returns the index of the triangle within the surface.

# Function Surface_GetNumTriangles:Int(surface:Object)
Returns the number of triangles in the surface.

# Function Surface_SetTriangleVertices:Void(surface:Object, index:Int, v0:Int, v1:Int, v2:Int)
Changes the vertex indices used by a specified triangle.

# Function Surface_GetTriangleV0:Int(surface:Object, index:Int)
Returns the index of the first vertex in the specified triangle.

# Function Surface_GetTriangleV1:Int(surface:Object, index:Int)
Returns the index of the second vertex in the specified triangle.

# Function Surface_GetTriangleV2:Int(surface:Object, index:Int)
Returns the index of the third vertex in the specified triangle.

# Function Surface_AddVertex:Int(surface:Object, x:Float, y:Float, z:Float, nx:Float, ny:Float, nz:Float, r:Float, g:Float, b:Float, opacity:Float, u:Float, v:Float)
Adds a new vertex to the surface, with the given position, normal, color, and texture coordinates. Returns the index of the vertex within the surface.

# Function Surface_GetNumVertices:Int(surface:Object)
Returns the number of vertices in the surface.

# Function Surface_SetVertexPosition:Void(surface:Object, index:Int, x:Float, y:Float, z:Float)
Sets the position of the specified vertex.

# Function Surface_SetVertexNormal:Void(surface:Object, index:Int, nx:Float, ny:Float, nz:Float)
Sets the normal vector of the specified vertex.

# Function Surface_SetVertexColor:Void(surface:Object, index:Int, r:Float, g:Float, b:Float, opacity:Float)
Sets the color of the specified vertex.

# Function Surface_SetVertexTexCoords:Void(surface:Object, index:Int, u:Float, v:Float)
Sets the texture coordinates of the specified vertex.

# Function Surface_SetVertexBone:Void(surface:Object, vertex:Int, index:Int, bone:Int, weight:Float)
Sets one of the bones that the vertex is attached to, and the weight that the bone has on the vertex (between 0 and 1).
A vertex can be attached to a maximum of four bones, specified in the `index` parameter with a value between 0 and 3.
Bone is the index within the mesh of the specified bone.

# Function Surface_GetVertexX:Float(surface:Object, index:Int)
Returns the X position of the specified vertex.

# Function Surface_GetVertexY:Float(surface:Object, index:Int)
Returns the Y position of the specified vertex.

# Function Surface_GetVertexZ:Float(surface:Object, index:Int)
Returns the Z position of the specified vertex.

# Function Surface_GetVertexNX:Float(surface:Object, index:Int)
Returns the X component of the normal of the specified vertex.

# Function Surface_GetVertexNY:Float(surface:Object, index:Int)
Returns the Y component of the normal of the specified vertex.

# Function Surface_GetVertexNZ:Float(surface:Object, index:Int)
Returns the Z component of the normal of the specified vertex.

# Function Surface_GetVertexRed:Float(surface:Object, index:Int)
Returns the red component of the color of the specified vertex.

# Function Surface_GetVertexGreen:Float(surface:Object, index:Int)
Returns the green component of the color of the specified vertex.

# Function Surface_GetVertexBlue:Float(surface:Object, index:Int)
Returns the blue component of the color of the specified vertex.

# Function Surface_GetVertexOpacity:Float(surface:Object, index:Int)
Returns the opacity of the specified vertex.

# Function Surface_GetVertexU:Float(surface:Object, index:Int)
Returns the U texture coordinate of the specified vertex.

# Function Surface_GetVertexV:Float(surface:Object, index:Int)
Returns the V texture coordinate of the specified vertex.

# Function Surface_GetVertexBoneIndex:Int(surface:Object, vertex:Int, index:Int)
Returns the specified vertex bone index.

# Function Surface_GetVertexBoneWeight:Float(surface:Object, vertex:Int, index:Int)
Return the specified vertex bone weight.

# Function Surface_Rebuild:Void(surface:Object)
Rebuilds the internal representation of the geometry in the surface.
To increase rendering performance, Vortex holds a copy of the data of all surfaces in video memory, so whenever you make a change to the geometry of a surface, you must call this function so the video memory is updated.

# Function Surface_Draw:Void(surface:Object)
Draws the surface. You don't normally need to call this function, because you will draw surfaces through drawables.




# Function Texture_Cache:Object(filename:String, filter:Int = FILTER_TRILINEAR)
Returns the texture with the specified filename, or Null if the texture was not found.
If the texture has been loaded previously by any cache object, that same object will be returned.
Otherwise, the last pushed cache object will load and return a new texture.

# Function Texture_Create:Object(buffer:DataBuffer, width:Int, height:Int, filter:Int)
Creates a new texture. Its pixel data will be generated from the passed memory `buffer`, with the specified `width` and `height`.
We must also specify one of the following filtering modes:

* FILTER_NONE
* FILTER_LINEAR
* FILTER_BILINEAR
* FILTER_TRILINEAR

You won't normally use this function directly, because textures can be obtained from image files using the `Texture_Cache` function.

# Function Texture_Free:Void(texture:Object)
Frees the resources used by this texture.
If you created the texture with the `Texture_Cache` function, then you must not call this function.
If you created the texture with `Texture_Create`, then you must call this function when you no longer need the texture.

# Function Texture_GetFilename:String(texture:Object)
Returns the filename that this texture was created from.

# Function Texture_GetHandle:Int(texture:Object)
Returns the internal handle of this texture. This is an identifier in video memory, and you don't normally need to use this value.

# Function Texture_GetWidth:Int(texture:Object)
Returns the width, in pixels, of the texture.

# Function Texture_GetHeight:Int(texture:Object)
Returns the height, in pixels, of the texture.

# Function Texture_Draw:Void(texture:Object, x:Float, y:Float, width:Float = 0, height:Float = 0, rectx:Float = 0, recty:Float = 0, rectwidth:Float = 0, rectheight:Float = 0)
Draws the texture to the specified screen coordinates.
You can also specifY a width and a height different than its original size, and a rectangle within the texture to draw instead of the whole thing.




# Function Viewer_Create:Object(vx:Int, vy:Int, vw:Int, vh:Int)
Creates a new viewer that draws in the specified screen viewport (rectangle).

# Function Viewer_Free:Void(viewer:Object)
When you no longer need to use the viewer, use this function to deallocate its internal resources.

# Function Viewer_SetPerspective:Void(viewer:Object, fovy:Float, ratio:Float, near:Float, far:Float)
Sets the perspective setup for this viewer.
The value of `fovy` represents the vertical focal angle that the screen captures.
Values normally go in the range [45,70].
The `ratio` is the proportion between the width and the height of the viewport that the viewer draws to (for example, 4/3, 16/9, 16/10... you normally get this value with the float division of the viewport width and height).
The values of `near` and `far` indicate the distance range from the viewer at which geometry is visible.
Nothing closer than `near` of further than `far` is drawn.

# Function Viewer_SetFrustum:Void(viewer:Object, left:Float, right:Float, bottom:Float, top:Float, near:Float, far:Float)
Sets the perspective frustum for this viewer.
The function `Viewer_SetPerspective` is easier to use and can achieve the same effect.

# Function Viewer_SetOrtho:Void(viewer:Object, left:Float, right:Float, bottom:Float, top:Float, near:Float, far:Float)
Sets the viewer to use an orthographic projection.
This can be used for isometric games, or in general any game where we don't want to use perspective (this is, we don't want objects to get smaller with distance).

# Function Viewer_SetClearColor:Void(viewer:Object, r:Float, g:Float, b:Float)
Sets the color with which the viewer viewport will be cleared before drawing thnrought this viewer's point of view.

# Function Viewer_GetClearRed:Float(viewer:Object)
Returns the red component of the viewer's clearing color.

# Function Viewer_GetClearGreen:Float(viewer:Object)
Returns the green component of the viewer's clearing color.

# Function Viewer_GetClearBlue:Float(viewer:Object)
Returns the blue component of the viewer's clearing color.

# Function Viewer_SetFog:Void(viewer:Object, enable:Bool, minDist:Float = 0, maxDist:Float = 0, r:Float = 0, g:Float = 0, b:Float = 0)
Enables or disables fog rendering for the viewer.
The value of `minDist` indicates the distance at which fog will begin to be visible, while `maxDist` indicates the distance to the viewer where the fog is completely opaque.
You can also specify the color of the fog.

# Function Viewer_SetViewport:Void(viewer:Object, x:Int, y:Int, w:Int, h:Int)
Sets the viewport that this viewer draws to.

# Function Viewer_GetViewportX:Float(viewer:Object)
Returns the X coordinate of the viewport (the rectangular area of the screen) that the viewer draws to.

# Function Viewer_GetViewportY:Float(viewer:Object)
Returns the Y coordinate of the viewport (the rectangular area of the screen) that the viewer draws to.

# Function Viewer_GetViewportWidth:Float(viewer:Object)
Returns the width of the viewport (the rectangular area of the screen) that the viewer draws to.

# Function Viewer_GetViewportHeight:Float(viewer:Object)
Returns the height of the viewport (the rectangular area of the screen) that the viewer draws to.

# Function Viewer_SetPosition:Void(viewer:Object, x:Float, y:Float, z:Float)
Sets the position of the viewer in the 3D space.

# Function Viewer_GetX:Float(viewer:Object)
Returns the X position of the viewer in the 3D space.

# Function Viewer_GetY:Float(viewer:Object)
Returns the Y position of the viewer in the 3D space.

# Function Viewer_GetZ:Float(viewer:Object)
Returns the Z position of the viewer in the 3D space.

# Function Viewer_SetEuler:Void(viewer:Object, x:Float, y:Float, z:Float)
Sets the rotation of the viewer, specified as an euler rotation around its XYZ axes.

# Function Viewer_GetEulerX:Float(viewer:Object)
Returns the euler rotation of the viewer around its X axis.

# Function Viewer_GetEulerY:Float(viewer:Object)
Returns the euler rotation of the viewer around its y axis.

# Function Viewer_GetEulerZ:Float(viewer:Object)
Returns the euler rotation of the viewer around its Z axis.

# Function Viewer_SetQuat:Void(viewer:Object, w:Float, x:Float, y:Float, z:Float)
Sets the rotation of the viewer, specified as a quaternion.

# Function Viewer_GetQuatW:Float(viewer:Object)
Returns the W component of the quaternion rotation of the viewer.

# Function Viewer_GetQuatX:Float(viewer:Object)
Returns the X component of the quaternion rotation of the viewer.

# Function Viewer_GetQuatY:Float(viewer:Object)
Returns the Y component of the quaternion rotation of the viewer.

# Function Viewer_GetQuatZ:Float(viewer:Object)
Returns the Z component of the quaternion rotation of the viewer.

# Function Viewer_Move:Void(viewer:Object, x:Float, y:Float, z:Float)
Translates the viewer from its current position the amount of points specified by the parameters, taking into account the current rotation of the drawable.
For example, `Viewer_Move(viewer, 0, 0, 1)` will move the viewer 1 point in the direction that it is facing (or upwards if you are using a right handed coordinate system with Z pointing upwards).

# Function Viewer_Prepare:Void(viewer:Object)
You must call this method before drawing any drawables.
It will prepare the viewport, clear it, define projection and view matrices, and averything else that needs to be done to be able to draw geometry in 3D space.




# Function Vortex_Init:Bool()
Initializes the Vortex library. This should be called before any other function in the library.

# Function Vortex_GetShaderError:String()
Reports any errors that took place while compiling the shaders on initialization.

# Function Vortex_GetAPIVersion:Float()
Get the version of the API supported by this machine (currently, the version of OpenGL supported by the implementation).

# Function Vortex_GetShadingVersion:Float()
Get the version of the shading language supported by this machine (currently, the version of GLSL supported by the implementation).
