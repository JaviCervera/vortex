# Module vortex

The Vortex module adds a very simple 3D rendering engine based on OpenGL ES 2.
More than a full 3D engine, it provides a lower-level API, similar to what the official Mojo offers for 2D.

>>> Coordinate systems and rotations
The handedness of the coordinate system can be selected when using Vortex.
To do that, you can write this at the beginning of your program:

`Import vortex.src.config`~n
`#VORTEX_HANDEDNESS=Mode`

Where `Mode` can be one of:
| Mode        | Description
| VORTEX_LH   | Left handed coordinate system where X points right, Y points up, and Z points away from the viewer. This is the convention in Direct3D, and the default mode in Vortex.
| VORTEX_RH_Y | Right handed coordinate system where X points right, Y points up, and Z points towards the viewer. This is the convention in OpenGL.
| VORTEX_RH_Z | Right handed coordinate system, where X points right, Y points away from the viewer, and Z points up. This was the default mode in previous versions of Vortex.

Rotations can be expressed both using quaternions and euler angles (expressed in degrees).

>>> Screen coordinates
The vertical direction of the screen can be selected when using Vortex.
To do that, you can write this at the beginning of your program:

`Import vortex.src.config`~n
`#VORTEX_SCREENCOORDS=Mode`

Where 'Mode' can be one of:
| Mode          | Description
| VORTEX_YDOWN  | Coordinates 0,0 represent the top left corner of the screen, while coordinates DeviceWidth(), DeviceHeight() represent the bottom right. This is common in several graphics libraries (like Mojo), and the default in Vortex.
| VORTEX_YUP    | Coordinates 0,0 represent the bottom left corner of the screen, while coordinates DeviceWidth(), DeviceHeight() represent the top right. This is a standard in math to define the Euclidean plane.

>>> Texture coordinates
On left handed coordinate systems, texture coordinates are mapped from the top left (coordinates 0,0) to the bottom right (coordinates 1,1).~n
On right handed coordinate systems, texture coordinates are mapped from the bottom left (coordinates 0,0) to the top right (coordinates 1,1).

>>> Triangle order
On left handed coordinate systems, front facing triangles are those that are mapped to the screen in clockwise order.~n
On right handed coordinate systems, front facing triangles are those that are mapped to the screen in counter clockwise order.~n
Back facing triangles are by default occluded by Vortex.




# Class Bone

A bone contains a list of transformations to be applied to the geometry attached to it when using animations. Meshes can contains bones that animate the surfaces of the mesh (to make it walk, for example).

# Function Create:Bone(name:String)
Creates a new bone with the specified name.

# Method GetName:String()
Returns the name of the bone.

# Method SetParent:Void(parent:Bone)
Sets the parent of the bone.

# Method GetParent:Bone()
Returns the parent of the bone, which will be another bone, or Null if it is the root bone in the mesh.

# Method CalcPoseMatrix:Void(px:Float, py:Float, pz:Float, rw:Float, rx:Float, ry:Float, rz:Float, sx:Float, sy:Float, sz:Float)
Sets the position, rotation (as a quaternion) and scale, relative to its parent, to be applied to the bone when it is not being rendered animated.
Although the parameters you pass here are relative to its parent, the generated matrix contains the globals transformation, so the parent's pose matrix must have been previously defined.
You don't need to use this function, unless you are generating meshes by hand. When loading a mesh from disk, this function will be called automatically by the loader.

# Method GetPoseMatrix:Float[]()
Returns a 16 float array that contains the global pose transform matrix.
You don't normally need to call this function.
It is used internally when rendering the geometry attached to the bone.

# Method GetInversePoseMatrix:Float[]()
Returns a 16 float array that contains the inverse of the global pose transform matrix.
You don't normally need to call this function.
It is used internally when rendering the geometry attached to the bone.

# Method AddSurface:Void(surf:Surface)
Adds a new surface to the bone. Surfaces attached to a bone contain geometry that is rendered with the transformation defined by the bone.
You don't need to use this function, unless you are generating meshes by hand. When loading a mesh from disk, this function will be called automatically by the loader.

# Method GetNumSurfaces:Int()
Returns the number of surfaces attached to the bone.

# Method GetSurface:Surface(index:Int)
Returns the specified surface attached to the bone. The value of `index` goes in the range `0 .. Bone_GetNumSurfaces(bone) - 1`.

# Method AddPositionKey:Void(keyframe:Int, x:Float, y:Float, z:Float)
Adds a new position transformation to the bone at the specified keyframe.

# Method AddRotationKey:Void(keyframe:Int, w:Float, x:Float, y:Float, z:Float)
Adds a new rotation quaternion to the bone at the specified keyframe.

# Method AddScaleKey:Void(keyframe:Int, x:Float, y:Float, z:Float)
Adds a new scale transformation to the bone at the specified keyframe.

# Method GetNumPositionKeys:Int()
Returns the number of position keyframes in the bone.

# Method GetPositionKeyFrame:Int(index:Int)
Returns the frame number of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Method GetPositionKeyX:Float(index:Int)
Returns the X coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Method GetPositionKeyY:Float(index:Int)
Returns the Y coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Method GetPositionKeyZ:Float(index:Int)
Returns the Z coordinate of the specified position keyframe. The value of `index` goes in the range `0 .. Bone_GetNumPositionKeys(bone) - 1`.

# Method GetNumRotationKeys:Int()
Returns the number of rotation keyframes in the bone.

# Method GetRotationKeyFrame:Int(index:Int)
Returns the frame number of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetRotationKeyW:Float(index:Int)
Returns the W quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetRotationKeyX:Float(index:Int)
Returns the X quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetRotationKeyY:Float(index:Int)
Returns the Y quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetRotationKeyZ:Float(index:Int)
Returns the Z quaternion coordinate of the specified rotation keyframe. The value of `index` goes in the range `0 .. Bone_GetNumRotationKeys(bone) - 1`.

# Method GetNumScaleKeys:Int()
Returns the number of scale keyframes in the bone.

# Method GetScaleKeyFrame:Int(index:Int)
Returns the frame number of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Method GetScaleKeyX:Float(index:Int)
Returns the X coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Method GetScaleKeyY:Float(index:Int)
Returns the Y coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.

# Method GetScaleKeyZ:Float(index:Int)
Returns the Z coordinate of the specified scale keyframe. The value of `index` goes in the range `0 .. Bone_GetNumScaleKeys(bone) - 1`.




# Class Brush

A brush represents material with visual information such as base texture, color, or opacity.
It is used to render objects with a specific appearance.

# Const BLEND_ALPHA:Int
# Const BLEND_ADD:Int
# Const BLEND_MUL:Int

# Function Create:Brush(baseTex:Texture = Null)
Create a new brush with the specified base texture.

# Method Set:Void(other:Brush)
Set the properties of the brush to be those of the one passed as parameter.

# Method SetBaseColor:Void(r:Float, g:Float, b:Float)
Sets the base color. Geometry is tinted using the base color, and it is also used as the diffuse component of the geometry using this brush in lighting calculations. The default value is white (1,1,1).

# Method GetRed:Float()
Returns the red component of the base color, in the range 0 .. 1.

# Method GetGreen:Float()
Returns the green component of the base color, in the range 0 .. 1.

# Method GetBlue:Float()
Returns the blue component of the base color, in the range 0 .. 1.

# Method SetOpacity:Void(opacity:Float)
Sets the opacity of the brush, with 0 being completely transparent and 1 being completely opaque. The default value is 1.

# Method GetOpacity:Float()
Returns the opacity of the brush, in the range 0 (transparent) .. 1 (opaque).

# Method SetShininess:Void(shininess:Float)
Sets the specular shininess of the brush. A value of 0 will disable specular reflections entirely, whereas a value in the range (0,1] will indicate the strength of the specular reflection.

# Method GetShininess:Float()
Returns the specular shininess of the brush.

# Method SetBaseTexture:Void(tex:Texture)
Sets the base texture of the brush.

# Method GetBaseTexture:Texture()
Returns the base texture of the brush, or Null if there is no base texture.

# Method SetBlendMode:Void(mode:Int)
Sets the blend mode of the brush. This defines how the final look of the geometry using this brush blends with the background, after computing texture, color and lighting information.

It takes one of the following values:

| Value             | Meaning
| BLEND_ALPHA | The computed alpha value of the brush (taking into account both brush opacity and texture alpha values) is used to blend with the background. This is the default value.
| BLEND_ADD   | The computed color of the brush is added to the background. This is useful to render "glow" geometry, such as fire and lasers.
| BLEND_MUL   | The computed color of the brush is multiplied with the background. This is useful to render lightmap geometry on top of other geometry.

# Method GetBlendMode:Int()
Returns the blend mode of the brush.

# Method SetCulling:Void(enable:Bool)
Enables or disables backface culling. When it is enabled, internal faces of the geometry using this brush will not be rendered. It is enabled by default.

# Method GetCulling:Bool()
Returns whether backface culling is enabled or not.

# Method SetDepthWrite:Void(enable:Bool)
Enabled or disables depth buffer writing. When it is disabled, other geometry further away from the viewer may occlude the geometry that uses this brush. It is enabled by default.

# Method GetDepthWrite:Bool()
Returns whether depth buffer writing is enabled or not.

# Method Prepare:Void()
Prepares this brush for drawing. All subsequent geometry drawn will use the visual properties of this brush. You normally do not need to use this method directly, it is used internally by `Drawable_Draw()`.




# Class Cache

The cache is used to avoid loading resources from disk more that once.
When you want to load a resource from disk (a texture, a mesh, or a font), Vortex will check if the resource was already loaded, in which case the same instance is returned to you, so it is not loaded multiple times in memory.

Internally, Vortex holds a stack of cache objects. You can add a new cache with the `Cache.Push` function, and all the resources loaded afterwards will be deallocated when the cache object is removed from the stack with `Cache.Pop`.
For example, on game initialization you could push a new cache object, and then load all the resources that are used throughout the entire game (menu textures and fonts, for example).
Then, when you are loading a new level, you push a new cache object and load all the resource of the level.
When you exit the level, you pop the cache object from the stack, deallocating all level resources, but the menu resources remain intact.
When you exit the game, you pop the last cache object, and all the resources allocated are cleared.

Upon initialization, Vortex always creates one cache object automatically.

# Function Push:Void()
Pushes a new cache object onto the stack. All resources loaded afterwards are handled by this cache object. When you pop this stack object with the `Cache.Pop` function, all the resources are deallocated.

# Function Pop:Void()
Pops the last pushed cache object from the stack, deallocating all the resources that were loaded after the creation of the cache object.

# Function GetFont:Font(filename:String)
Returns the font with the specified filename, or Null if it could not be found.
If the font has been loaded previously by any cache object, that same object will be returned.
Otherwise, the last pushed cache object will load and return a new font.

# Function GetMesh:Mesh(filename:String, texFilter:Int = Texture.FILTER_TRILINEAR)
Returns the mesh with the specified filename, or Null if it could not be found.
If the mesh has been loaded previously by any cache object, that same object will be returned. Otherwise, the last pushed cache object will load and return a new mesh.

# Function GetTexture:Texture(filename:String, filter:Int = Texture.FILTER_TRILINEAR)
Returns the texture with the specified filename, or Null if the texture was not found.
If the texture has been loaded previously by any cache object, that same object will be returned.
Otherwise, the last pushed cache object will load and return a new texture.




# Class Drawable

A drawable represents a visible object that can be rendered in a position of 3D space, with an specific rotation and scale.
Examples of drawables are the following:
* A 3D object (called a mesh), which can be static or animated, and can contain one or more surfaces (a surface is a set of geometry that uses the same brush texture, color...).
* A single surface.
* A plain billboard that always faces the camera.

# Function Create:Drawable(mesh:Mesh)
Creates a new drawable that renders a mesh.

# Function Create:Drawable(surface:Surface)
Creates a new drawable with an empty surface.
You can add indices and vertices to this surface and call `Surface.Rebuild()` to regenerate internal buffers.
After you call `Drawable.Free()` on this drawable, the surface will be automatically freed.

# Function Create:Drawable(brush:Brush, width:Float = 0, height:Float = 0, mode:Int = BILLBOARD_SPHERICAL)
Creates a new drawable that renders a billboard.
We must specify a texture that will define how the billboard looks.
We can specify a custom with and height or leave these values at 0 to use the texture size.

The `mode` parameter indicates how the billboard is oriented to face the viewer, and can take one of the following values:

| Value                  | Meaning
| Drawable.BILLBOARD_SPHERICAL    | The billboard's X and Y (or Z when using a right-handed coordinate system) axes are oriented to face the viewer.
| Drawable.BILLBOARD_CYLINDRICAL  | The billboard's Y (or Z when using a right-handed coordinate system) axis is oriented to face the viewer.

# Method Free:Void()
When a drawable is no longer going to be used, we must use this method to deallocate the resources that it uses.

# Method Animate:Void(frame:Float, firstFrame:Int = 0, lastFrame:Int = 0)
Updates the internal animation matrices so hold the animation data for the specified `frame`. We can indicate the first and last frames in the animation sequence if the mesh contains frames for several animations (for example: walk, jump, shoot, etc).

# Method Draw:Void(animated:Bool = False)
Renders a drawable with its current transformation in the 3D space (position, rotation and scale).
If the drawable contains an animated mesh, we can indicate whether we want to draw the mesh static or animated.

# Method GetBillboardMode:Int()
Returns the billboarding mode that this drawable has, or BILLBOARD_NONE if the drawable is not a billboard.

# Method GetMesh:Mesh()
Returns the mesh attached to this billboard, or Null if there is none.

# Method GetSurface:Surface()
Returns the surface attached to this billboard, or Null if there is none.

# Method SetPosition:Void(x:Float, y:Float, z:Float)
Set the position of the drawable in 3D space.

# Method GetX:Float()
Returns the X position of the drawable in 3D space.

# Method GetY:Float()
Returns the Y position of the drawable in 3D space.

# Method GetZ:Float()
Returns the Z position of the drawable in 3D space.

# Method SetEuler:Void(x:Float, y:Float, z:Float)
Sets the rotation of the drawable, specified as an euler rotation around its XYZ axes.

# Method GetEulerX:Float()
Returns the euler rotation of the drawable around its X axis.

# Method GetEulerY:Float()
Returns the euler rotation of the drawable around its Y axis.

# Method GetEulerZ:Float()
Returns the euler rotation of the drawable around its Z axis.

# Method SetQuat:Void(w:Float, x:Float, y:Float, z:Float)
Sets the rotation of the drawable, specified as a quaternion.

# Method GetQuatW:Float()
Returns the W component of the quaternion rotation of the drawable.

# Method GetQuatX:Float()
Returns the X component of the quaternion rotation of the drawable.

# Method GetQuatY:Float()
Returns the Y component of the quaternion rotation of the drawable.

# Method GetQuatZ:Float()
Returns the Z component of the quaternion rotation of the drawable.

# Method SetScale:Void(x:Float, y:Float, z:Float)
Sets the scale factor of the drawable, with 1,1,1 being its original size, 2,2,2 being twice its original size, etc.

# Method GetScaleX:Float()
Returns the X scale factor of the drawable.

# Method GetScaleY:Float()
Returns the Y scale factor of the drawable.

# Method GetScaleZ:Float()
Returns the X scale factor of the drawable.

# Method Move:Void(x:Float, y:Float, z:Float)
Translates the drawable from its current position the amount of points specified by the parameters, taking into account the current rotation of the drawable.
For example, `drawable.Move(0, 0, 1)` will move the drawable 1 point in the direction that it is facing (or upwards when using a right handed coordinate system).




# Class Font

A font is used to render text in Vortex.
It is composed by a texture which contains the characters used to render texts, and a set of glyphs which contains the coordinates of each character within the texture and its offset.
You normally don't generate fonts by hand, but by using the bundled fonttool utility.

# Function Create:Font(filename:String, height:Float, tex:Texture)
Creates a new font, assigning a filename to it, the heigth in pixels of the font, and the texture map that will be used to render texts with this font. After creating it, you should define its glyphs. You normally don't need to use this function, as `Cache.GetFont` gives you a font ready to use.

# Method Free:Void()
When you are not going to render text usign this font anymore, you can call this method to deallocate its resources. If you are using the cache for loading resources, you don't need to call this method, since all cache resources are deallocated when clearing the cache.

# Method GetFilename:String()
Returns the filename of the font.

# Method GetHeight:Float()
Returns the height in pixels of the font.

# Method GetTexture:Texture()
Returns the texture map for this font.

# Method GetTextWidth:Float(text:String)
Returns the width in pixels that the specified text needs to be rendered with the font.

# Method GetTextHeight:Float(text:String)
Returns the width in pixels that the specified text needs to be rendered with the font.

# Method Draw:Void(x:Float, y:Float, text:String)
Draws the specified text at the given x, y screen coordinates.

# Method SetGlyphData:Void(index:Int, x:Float, y:Float, w:Float, h:Float, yoffset:Float)
Sets the rectangle within the font texture where the character with the specified index (it's ASCII code) is located, and the Y offset to render the character relative to the Y drawing coordinate.




# Class Lighting

Vortex supports defining lights sources that can shine on objects.
The maximum number of lights that can be defined simultaneously is 8.
All of these can emit one colored light that can be reflected by objects.

When a light ray hits an object, the color of the light is combined with the color of the object, and that defines the appearance of the object.
This is called *diffuse lighting*.

Also, an object can have a shininess power, which will produce highlights when a light ray hits the objects. This gives the appearance of a shiny object, like a metal surface, and is called *specular lighting*.

Finally, independently from how many light rays are hitting an object, every object also receives some amount of residual lighting, produced by all the lights. This is called *ambient lighting*.
For example, if we are in a sunny open environment, the amount of ambient lighting is much bigger than in a narrow, dark cave, because the intensity of all the lights produce a brighter residual lighting.

Lights can be at infinity, emitting rays in one direction (called *directional lights*; one common example is the sun),
or can be at one specific place, emitting rays in all directions that attenuate with distance (called *point lights*).

# Const NUM_LIGHTS : Int
# Const DIRECTIONAL : Int
# Const POINT : Int

# Function SetLightEnabled:Void(index:Int, enabled:Bool)
Sets whether the light with the specified index (in the range [0,7]) must be taken into account or not when computing lighting.

# Function IsLightEnabled:Bool(index:Int)
Returns whether the specified light is enabled or not.

# Function SetLightType:Void(index:Int, type:Int)
Sets the type of the specified light. It can take one of the following values:

| Value                | Meaning
| Lighting.DIRECTIONAL | A directional light. This light behaves as a light source coming from infinity with the direction specified by a normal vector, and this type of lighting is commonly used to represent the sun light. This is the default value.
| Lighting.POINT       | A point light. This light is placed at a position in the 3D space, and attenuates with distance. The linear attenuation factor can be specified with the `Lighting.SetLightAttenuation` function.

# Function GetLightType:Int(index:Int)
Returns the type of the specified light.

# Function SetLightPosition:Void(index:Int, x:Float, y:Float, z:Float)
Sets the position of the specified light in 3D space. In directional lights, this value is a normal vector that indicates the direction that the light is coming from.

# Function GetLightX:Float(index:Int)
Returns the X position of the specified light.

# Function GetLightY:Float(index:Int)
Returns the Y position of the specified light.

# Function GetLightZ:Float(index:Int)
Returns the Z position of the specified light.

# Function SetLightColor:Void(index:Int, r:Float, g:Float, b:Float)
Sets the color that the specified light emits. White by default (1,1,1).

# Function GetLightRed:Float(index:Int)
Returns the red component of the specified light color.

# Function GetLightGreen:Float(index:Int)
Returns the green component of the specified light color.

# Function GetLightBlue:Float(index:Int)
Returns the blue component of the specified light color.

# Function SetLightAttenuation:Void(index:Int, att:Float)
Sets the attenuation factor of the specified light. This value is ignored for directional lights.

# Function GetLightAttenuation:Float(index:Int)
Returns the attenuation factor of the specified light.

# Function Prepare:Void(ambientRed:Float = 0.3, ambientGreen:Float = 0.3, ambientBlue:Float = 0.3)
Prepares the engine to render with lighting in the next frame, using the color color components specified
as parameters as the ambient color (this is, the lighting that will be received by all geometry independent from the light sources).
Required lights must have been previously enabled and configured. If you do not call this before drawing your scene,
no lighting information will be computed, despite of which lights were enabled.




# Class Mesh

A mesh is the description of a set of geometry (triangles), brushes and optional animations that belong to one object.
For every brush that we need, there will be a surface in the mesh containing the geometry to be drawn with that brush.
The standard way to draw a mesh on the 3D space is by creating a Drawable from this mesh, and giving it a position, rotation and scale. Several drawables can be created from the same mesh.

# Function Create:Mesh(skinned:Bool = False)
Creates a new empty mesh. This function is used if we want to generate meshes procedurally.
You must indicate whether the mesh is skinned (it has bone weights information for animation) or not.
If you want to load meshes from disk, the the `Cache.GetMesh` function instead.

# Method Free:Void()
When we don't need to use this mesh anymore (for example, if there are no more drawables that use it and we do not plan to create new ones), we can use this function to deallocate its resources.
If the mesh has been created with the function `Cache.GetMesh`, we must not call this method.

# Method GetFilename:String()
Returns the filename assigned to this mesh when it cas created.

# Method SetFilename:Void(filename:String)
Sets the filename of the mesh. This is useful if you are implementing a custom mesh loader and you want to identify the filename that the mesh was created from.

# Method AddSurface:Void(surf:Surface)
Creates a new surface on the mesh and returns its handle.
A surface is a set of geometry that use the same brush and it's attached to a same bone (if the mesh is animated).

# Method GetNumSurfaces:Int()
Returns the number of surfaces that this mesh contains.

# Method GetSurface:Surface(index:Int)
Returns a surface contained in the mesh. The value of `index` must be in the range `[0, GetNumSurfaces()-1]`.

# Method SetLastFrame:Void(lastFrame:Int)
Sets the last animation frame for the mesh. You should call this method only if generating an animated mesh procedurally, but not when loading the mesh from disk.

# Method GetLastFrame:Int()
Returns the last animation frame contained in the mesh.

# Method AddBone:Void(bone:Bone)
Adds a new bone to the mesh.

# Method GetNumBones:Int()
Gets the number of bones in the mesh.

# Method GetBone:Bone(index:Int)
Gets the bone at the specified `index`, which is a value between `0` and `GetNumBones`.

# Method FindBone:Bone(name:String)
If a bone with the specified name is found on the mesh, returns it. If not, it returns `Null`.

# Method Animate:Void(animMatrices:Mat4[], frame:Float, firstFrame:Int = 0, lastFrame:Int = 0)
Calculates animation data for the specified frame in the mesh and updates the matrices in `animMatrices` using this data.

# Method Draw:Void(animated:Bool = False, animMatrices:Mat4[] = [])
Renders the mesh. You normally do this through a drawable, so there is no need to call this function.




# Class Renderer

The Renderer is the class used to draw graphics on the screen in immediate mode, and the direct link with the underlying rendering API (OpenGL). For most stuff, you do not need to deal with this class directly, but for example if you want to draw your 2D graphics above the 3D scene, after drawing all your 3D geometry, you must call `Painter.Setup2D` to setup the context for 2D drawing, and then perform your drawing operations.

# Function Setup2D:Void(x:Int, y:Int, width:Int, height:Int)
Setup the context for 2D painting. The parameters define the rectangle within the screen where drawing will take place. You must call this function before doing any 2D drawing.

# Function Setup3D:Void(x:Int, y:Int, width:Int, height:Int)
Setup the context for 3D painting. The parameters define the rectangle within the screen where drawing will take place.
You must call this function if you want to draw 3D geometry using `Mesh_Draw` and `Surface_Draw`.
If you are going to render geometry using viewers and drawables (the usual thing), then you don't need to call this function.

# Function SetProjectionMatrix:Void(m:Mat4)
Setup the projection matrix. You must call this function if you want to draw 3D geometry using `Mesh.Draw` and `Surface.Draw`.
If you are going to render geometry using viewers and drawables (the usual thing), then you don't need to call this function.

# Function GetProjectionMatrix:Mat4()
Returns the currently active projection matrix.

# Function SetViewMatrix:Void(m:Mat4)
Setup the view matrix. You must call this function if you want to draw 3D geometry using `Mesh.Draw` and `Surface.Draw`.
If you are going to render geometry using viewers and drawables (the usual thing), then you don't need to call this function.

# Function GetViewMatrix:Mat4()
Returns the currently active view matrix.

# Function SetModelMatrix:Void(m:Mat4)
Setup the model matrix. You must call this function if you want to draw 3D geometry using `Mesh.Draw` and `Surface.Draw`.
If you are going to render geometry using viewers and drawables (the usual thing), then you don't need to call this function.

# Function GetModelMatrix:Mat4()
Returns the currently active model matrix.

# Function SetBlendMode:Void(mode:Int)
Sets the blend mode to use when painting. Possible values are:

| Value       | Meaning
| Renderer.BLEND_ALPHA | The computed alpha value (taking into account both opacity and texture alpha values) is used to blend with the background. This is the default value.
| Renderer.BLEND_ADD   | The computed color is added to the background. This is useful to render "glow" geometry, such as fire and lasers.
| Renderer.BLEND_MUL   | The computed color is multiplied with the background. This is useful to render lightmap geometry on top of other geometry.

# Function SetColor:Void(r:Float, g:Float, b:Float, a:Float = 1)
Sets the drawing color.

# Function ClearColorBuffer:Void(r:Float = 0, g:Float = 0, b:Float = 0)
Clears the background (actually, the boundaries defined when the call to `Renderer.Setup2D` or `Renderer.Setup3D` was made) with the specified color.

# Function DrawPoint:Void(x:Float, y:Float, z:Float)
Draws a point at the specified coordinates. For 2D graphics, `z` should be 0.

# Function DrawLine:Void(x1:Float, y1:Float, z1:Float, x2:Float, y2:Float, z2:Float)
Draws a line that goes from x1, y1 to x2, y2. For 2D graphics, both `z1` and `z2` should be 0.

# Function DrawRect:Void(x:Float, y:Float, z:Float, width:Float, height:Float)
Draws a filled rectangle at the specified coordinates, with the given width and height. For 2D graphics, `z` should be 0.

# Function DrawEllipse:Void(x:Float, y:Float, z:Float, width:Float, height:Float)
Draw a filled ellipse at the specified coordinates, with the given width and height. For 2D graphics, `z` should be 0.




# Class Surface

The surface class contains a set of geometry (vertices and indices that form triangles) and a brush to draw that geometry.

# Function Create:Surface(brush:Brush = Null)
Creates a new surface. If a brush is passed, it will be copied. If not, a new brush will be created for the surface.

# Method Free:Void()
Deallocates all the resources used by this surface. You don't normally need to call this method directly, since meshes call this method on all their surfaces when the mesh itself is discarded, and drawables that contain a single surface also discard the surface when the drawable is discarded.

# Method GetBrush:Brush()
Returns the brush that this surface uses.

# Method AddTriangle:Int(v0:Int, v1:Int, v2:Int)
Adds a new triangle to the surface. A triangle contains three indices, that reference the vertices in the surface. Returns the index of the triangle within the surface.

# Method GetNumTriangles:Int()
Returns the number of triangles in the surface.

# Method SetTriangleVertices:Void(index:Int, v0:Int, v1:Int, v2:Int)
Changes the vertex indices used by a specified triangle.

# Method GetTriangleV0:Int(index:Int)
Returns the index of the first vertex in the specified triangle.

# Method GetTriangleV1:Int(index:Int)
Returns the index of the second vertex in the specified triangle.

# Method GetTriangleV2:Int(index:Int)
Returns the index of the third vertex in the specified triangle.

# Method AddVertex:Int(x:Float, y:Float, z:Float, nx:Float, ny:Float, nz:Float, r:Float, g:Float, b:Float, a:Float, u:Float, v:Float)
Adds a new vertex to the surface, with the given position, normal, color, and texture coordinates. Returns the index of the vertex within the surface.

# Method GetNumVertices:Int()
Returns the number of vertices in the surface.

# Method SetVertexPosition:Void(index:Int, x:Float, y:Float, z:Float)
Sets the position of the specified vertex.

# Method SetVertexNormal:Void(index:Int, nx:Float, ny:Float, nz:Float)
Sets the normal vector of the specified vertex.

# Method SetVertexColor:Void(index:Int, r:Float, g:Float, b:Float, a:Float)
Sets the color of the specified vertex.

# Method SetVertexTexCoords:Void(index:Int, u:Float, v:Float)
Sets the texture coordinates of the specified vertex.

# Method SetVertexBone:Void(vertex:Int, index:Int, bone:Int, weight:Float)
Sets one of the bones that the vertex is attached to, and the weight that the bone has on the vertex (between 0 and 1).
A vertex can be attached to a maximum of four bones, specified in the `index` parameter with a value between 0 and 3.
Bone is the index within the mesh of the specified bone.

# Method GetVertexX:Float(index:Int)
Returns the X position of the specified vertex.

# Method GetVertexY:Float(index:Int)
Returns the Y position of the specified vertex.

# Method GetVertexZ:Float(index:Int)
Returns the Z position of the specified vertex.

# Method GetVertexNX:Float(index:Int)
Returns the X component of the normal of the specified vertex.

# Method GetVertexNY:Float(index:Int)
Returns the Y component of the normal of the specified vertex.

# Method GetVertexNZ:Float(index:Int)
Returns the Z component of the normal of the specified vertex.

# Method GetVertexRed:Float(index:Int)
Returns the red component of the color of the specified vertex.

# Method GetVertexGreen:Float(index:Int)
Returns the green component of the color of the specified vertex.

# Method GetVertexBlue:Float(index:Int)
Returns the blue component of the color of the specified vertex.

# Method GetVertexOpacity:Float(index:Int)
Returns the opacity of the specified vertex.

# Method GetVertexU:Float(index:Int)
Returns the U texture coordinate of the specified vertex.

# Method GetVertexV:Float(index:Int)
Returns the V texture coordinate of the specified vertex.

# Method GetVertexBoneIndex:Int(vertex:Int, index:Int)
Returns the specified vertex bone index.

# Method GetVertexBoneWeight:Float(vertex:Int, index:Int)
Return the specified vertex bone weight.

# Method Rebuild:Void()
Rebuilds the internal representation of the geometry in the surface.
To increase rendering performance, Vortex holds a copy of the data of all surfaces in video memory, so whenever you make a change to the geometry of a surface, you must call this function so the video memory is updated.

# Method Draw:Void()
Draws the surface. You don't normally need to call this function, because you will draw surfaces through drawables.




# Class Texture

A texture represents a buffer in video memory that contains pixel data.
Textures can be contained in brushes and applied to objects together with other information like color and opacity, or drawn to the screen directly (for example to render 2D sprites).

# Const FILTER_NONE:Int
# Const FILTER_LINEAR:Int
# Const FILTER_BILINEAR:Int
# Const FILTER_TRILINEAR:Int

# Function Create:Texture(filename:String, filter:Int)
Loads a texture from disk.
We must also specify one of the following filtering modes:

* Texture.FILTER_NONE
* Texture.FILTER_LINEAR
* Texture.FILTER_BILINEAR
* Texture.FILTER_TRILINEAR

You won't normally use this function directly, because textures can be obtained from image files using the `Cache.GetTexture` function.

# Function Create:Texture(buffer:DataBuffer, width:Int, height:Int, filter:Int)
Creates a new texture. Its pixel data will be generated from the passed memory `buffer`, with the specified `width` and `height`.
We must also specify one of the following filtering modes:

* Texture.FILTER_NONE
* Texture.FILTER_LINEAR
* Texture.FILTER_BILINEAR
* Texture.FILTER_TRILINEAR

You won't normally use this function directly, because textures can be obtained from image files using the `Cache.GetTexture` function.

# Method Free:Void()
Frees the resources used by this texture.
If you created the texture with the `Cache.GetTexture` function, then you must not call this function.
If you created the texture with `Texture.Create`, then you must call this function when you no longer need the texture.

# Method GetFilename:String()
Returns the filename that this texture was created from.

# Method GetHandle:Int()
Returns the internal handle of this texture. This is an identifier in video memory, and you don't normally need to use this value.

# Method GetWidth:Int()
Returns the width, in pixels, of the texture.

# Method GetHeight:Int()
Returns the height, in pixels, of the texture.

# Method Draw:Void(x:Float, y:Float, width:Float = 0, height:Float = 0, rectx:Float = 0, recty:Float = 0, rectwidth:Float = 0, rectheight:Float = 0)
Draws the texture to the specified screen coordinates.
You can also specifY a width and a height different than its original size, and a rectangle within the texture to draw instead of the whole thing.




# Class Viewer

A viewer is an observer of the 3D world.
It has a position and rotation in 3D space, a rectangle in the screen to draw to, as well as other parameters.
In a single player game, you should have at least one viewer representing what the player sees on the entire screen.
In a split screen multiplayer game, you will have one viewer per player, each drawing to a different rectangle of the screen.

The default way to render 3D objects in Vortex is by placing objects using drawables, and drawing to the screen with the data specified by one or more viewers.

# Function Create:Viewer(vx:Int, vy:Int, vw:Int, vh:Int)
Creates a new viewer that draws in the specified screen viewport (rectangle).

# Method SetPerspective:Void(fovy:Float, ratio:Float, near:Float, far:Float)
Sets the perspective setup for this viewer.
The value of `fovy` represents the vertical focal angle that the screen captures.
Values normally go in the range [45,70].
The `ratio` is the proportion between the width and the height of the viewport that the viewer draws to (for example, 4/3, 16/9, 16/10... you normally get this value with the float division of the viewport width and height).
The values of `near` and `far` indicate the distance range from the viewer at which geometry is visible.
Nothing closer than `near` of further than `far` is drawn.

# Method SetFrustum:Void(left:Float, right:Float, bottom:Float, top:Float, near:Float, far:Float)
Sets the perspective frustum for this viewer.
The function `Viewer_SetPerspective` is easier to use and can achieve the same effect.

# Method SetOrtho:Void(left:Float, right:Float, bottom:Float, top:Float, near:Float, far:Float)
Sets the viewer to use an orthographic projection.
This can be used for isometric games, or in general any game where we don't want to use perspective (this is, we don't want objects to get smaller with distance).

# Method SetClearColor:Void(r:Float, g:Float, b:Float)
Sets the color with which the viewer viewport will be cleared before drawing thnrought this viewer's point of view.

# Method GetClearRed:Float()
Returns the red component of the viewer's clearing color.

# Method GetClearGreen:Float()
Returns the green component of the viewer's clearing color.

# Method GetClearBlue:Float()
Returns the blue component of the viewer's clearing color.

# Method SetFog:Void(enable:Bool, minDist:Float = 0, maxDist:Float = 0, r:Float = 0, g:Float = 0, b:Float = 0)
Enables or disables fog rendering for the viewer.
The value of `minDist` indicates the distance at which fog will begin to be visible, while `maxDist` indicates the distance to the viewer where the fog is completely opaque.
You can also specify the color of the fog.

# Method SetViewport:Void(x:Int, y:Int, w:Int, h:Int)
Sets the viewport that this viewer draws to.

# Method GetViewportX:Float()
Returns the X coordinate of the viewport (the rectangular area of the screen) that the viewer draws to.

# Method GetViewportY:Float()
Returns the Y coordinate of the viewport (the rectangular area of the screen) that the viewer draws to.

# Method GetViewportWidth:Float()
Returns the width of the viewport (the rectangular area of the screen) that the viewer draws to.

# Method GetViewportHeight:Float()
Returns the height of the viewport (the rectangular area of the screen) that the viewer draws to.

# Method SetPosition:Void(x:Float, y:Float, z:Float)
Sets the position of the viewer in the 3D space.

# Method GetX:Float()
Returns the X position of the viewer in the 3D space.

# Method GetY:Float()
Returns the Y position of the viewer in the 3D space.

# Method GetZ:Float()
Returns the Z position of the viewer in the 3D space.

# Method SetEuler:Void(x:Float, y:Float, z:Float)
Sets the rotation of the viewer, specified as an euler rotation around its XYZ axes.

# Method GetEulerX:Float()
Returns the euler rotation of the viewer around its X axis.

# Method GetEulerY:Float()
Returns the euler rotation of the viewer around its y axis.

# Method GetEulerZ:Float()
Returns the euler rotation of the viewer around its Z axis.

# Method SetQuat:Void(w:Float, x:Float, y:Float, z:Float)
Sets the rotation of the viewer, specified as a quaternion.

# Method GetQuatW:Float()
Returns the W component of the quaternion rotation of the viewer.

# Method GetQuatX:Float()
Returns the X component of the quaternion rotation of the viewer.

# Method GetQuatY:Float()
Returns the Y component of the quaternion rotation of the viewer.

# Method GetQuatZ:Float()
Returns the Z component of the quaternion rotation of the viewer.

# Method Move:Void(x:Float, y:Float, z:Float)
Translates the viewer from its current position the amount of points specified by the parameters, taking into account the current rotation of the drawable.
For example, `Viewer_Move(viewer, 0, 0, 1)` will move the viewer 1 point in the direction that it is facing (or upwards if you are using a right handed coordinate system with Z pointing upwards).

# Method Prepare:Void()
You must call this method before drawing any drawables.
It will prepare the viewport, clear it, define projection and view matrices, and averything else that needs to be done to be able to draw geometry in 3D space.




# Class Vortex

This class contains some global general porpose functions to setup the library and get status information.

# Function Init:Bool()
Initializes the Vortex library. This should be called before any other function in the library.

# Function GetShaderError:String()
Reports any errors that took place while compiling the shaders on initialization.

# Function GetAPIVersion:Float()
Get the version of the API supported by this machine (currently, the version of OpenGL supported by the implementation).

# Function GetShadingVersion:Float()
Get the version of the shading language supported by this machine (currently, the version of GLSL supported by the implementation).
