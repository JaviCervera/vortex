Strict

Private
Import color
Import math3d
Import renderlist
Import renderer
Import shader
Import texture

Public

Class Material Final
Public
	Method New(colorTex:Texture = Null)
		mColor = color.Color.WHITE
		mColorTex = colorTex
		mShininess = 0
		mRefractCoef = -1
		mBlendMode = Renderer.BLEND_SOLID
		mCulling = True
		mDepthWrite = True
		mCastShadows = True
		Mat4Identity(mTextureMatrix)
	End
	
	Method New(other:Material)
		Set(other)
	End
	
	Method DiscardTextures:Void()
		If mColorTex Then mColorTex.Discard()
		If mNormalTex Then mNormalTex.Discard()
		If mSpecularTex Then mSpecularTex.Discard()
		If mLightTex Then mLightTex.Discard()
		If mCubeTex Then mCubeTex.Discard()
	End
	
	Method IsEqual:Bool(other:Material)
		If Self = other Then Return True
		If mColor = other.mColor And mColorTex = other.mColorTex And mNormalTex = other.mNormalTex And mSpecularTex = other.mSpecularTex And mLightTex = other.mLightTex And mCubeTex = other.mCubeTex And mShininess = other.mShininess And mRefractCoef = other.mRefractCoef And mBlendMode = other.mBlendMode And mCulling = other.mCulling And mDepthWrite = other.mDepthWrite And mCastShadows = other.mCastShadows
			Return True
		Else
			Return False
		End
	End

	Method Set:Void(other:Material)
		If Self.IsEqual(other) Then Return
		mColor = other.mColor
		mColorTex = other.mColorTex
		mNormalTex = other.mNormalTex
		mSpecularTex = other.mSpecularTex
		mLightTex = other.mLightTex
		mCubeTex = other.mCubeTex
		mShininess = other.mShininess
		mRefractCoef = other.mRefractCoef
		mBlendMode = other.mBlendMode
		mCulling = other.mCulling
		mDepthWrite = other.mDepthWrite
		mCastShadows = other.mCastShadows
		Mat4Copy(other.mTextureMatrix, mTextureMatrix)
	End
	
	Method Color:Void(color:Int) Property
		mColor = color
	End

	Method Color:Int() Property
		Return mColor
	End
	
	Method ColorTexture:Void(tex:Texture) Property
		mColorTex = tex
	End

	Method ColorTexture:Texture() Property
		Return mColorTex
	End
	
	Method NormalTexture:Void(tex:Texture) Property
		mNormalTex = tex
	End
	
	Method NormalTexture:Texture() Property
		Return mNormalTex
	End
	
	Method SpecularTexture:Void(tex:Texture) Property
		mSpecularTex = tex
	End
	
	Method SpecularTexture:Texture() Property
		Return mSpecularTex
	End
	
	Method LightTexture:Void(tex:Texture) Property
		mLightTex = tex
	End
	
	Method LightTexture:Texture() Property
		Return mLightTex
	End
	
	Method CubeTexture:Void(tex:Texture) Property
		mCubeTex = tex
	End
	
	Method CubeTexture:Texture() Property
		Return mCubeTex
	End
	
	Method RefractionTexture:Void(tex:Texture) Property
		mRefractTex = tex
	End
	
	Method RefractionTexture:Texture() Property
		Return mRefractTex
	End

	Method Shininess:Void(shininess:Float) Property
		'shininess = Clamp(shininess, 0.0, 1.0)
		mShininess = shininess
	End

	Method Shininess:Float() Property
		Return mShininess
	End
	
	Method RefractionCoef:Void(coef:Float) Property
		mRefractCoef = coef
	End
	
	Method RefractionCoef:Float() Property
		Return mRefractCoef
	End

	Method BlendMode:Void(mode:Int) Property
		mBlendMode = mode
	End

	Method BlendMode:Int() Property
		Return mBlendMode
	End

	Method Culling:Void(enable:Bool) Property
		mCulling = enable
	End

	Method Culling:Bool() Property
		Return mCulling
	End

	Method DepthWrite:Void(enable:Bool) Property
		mDepthWrite = enable
	End

	Method DepthWrite:Bool() Property
		Return mDepthWrite
	End
	
	Method CastShadows:Void(enable:Bool) Property
		mCastShadows = enable
	End
	
	Method CastShadows:Bool() Property
		Return mCastShadows
	End
	
	Method TextureMatrix:Float[]() Property
		Return mTextureMatrix
	End

	Method _PrepareForRender:Bool(step_:Int)
		'Abort if this material does not render in this step
		If step_ = STEP_SHADOWS And (mBlendMode <> Renderer.BLEND_SOLID Or Not CastShadows) Then Return False
		If step_ = STEP_SOLID And (mBlendMode <> Renderer.BLEND_SOLID Or Not mDepthWrite) Then Return False
		If step_ = STEP_DEPTHWRITE And (mBlendMode = Renderer.BLEND_SOLID Or Not mDepthWrite) Then Return False
		If step_ = STEP_NODEPTHWRITE And mDepthWrite Then Return False
	
		Local colorHandle:Int = 0
		Local normalHandle:Int = 0
		Local specularHandle:Int = 0
		Local lightHandle:Int = 0
		Local cubeHandle:Int = 0

		Renderer.SetColor(mColor)
		Renderer.State().Shininess = mShininess
		Renderer.State().RefractCoef = mRefractCoef
		Renderer.SetBlendMode(mBlendMode)
		Renderer.SetCulling(mCulling)
		If Not Renderer.State().SeparateDepthPass Or step_ <> STEP_SOLID Then Renderer.SetDepthWrite(mDepthWrite)
		Mat4Copy(mTextureMatrix, Renderer.State().TextureMatrix)
		If mColorTex <> Null Then colorHandle = mColorTex.Handle
		If mNormalTex <> Null Then normalHandle = mNormalTex.Handle
		If mSpecularTex <> Null Then specularHandle = mSpecularTex.Handle
		If mLightTex <> Null Then lightHandle = mLightTex.Handle
		If mCubeTex <> Null Then cubeHandle = mCubeTex.Handle
		Renderer.SetTextures(colorHandle, normalHandle, specularHandle, lightHandle, cubeHandle, mColorTex And mColorTex.IsCubic)
		
		'Prepare bound shader
		Shader._Bound().Prepare()
		
		Return True
	End
	
	'Used internally by the engine
	Const STEP_SHADOWS:Int = 0				'Shadow step
	Const STEP_SOLID:Int = 1					'Solid blend with depth writing
	Const STEP_DEPTHWRITE:Int = 2			'Other blends with depth writing
	Const STEP_NODEPTHWRITE:Int = 3		'All entitites with no depth writing
	Const STEP_COUNT:Int = 4
Private
	Field mColor					: Int
	Field mColorTex				: Texture
	Field mNormalTex			: Texture
	Field mSpecularTex    : Texture
	Field mLightTex				: Texture
	Field mCubeTex				: Texture
	Field mShininess			: Float
	Field mRefractCoef		: Float
	Field mBlendMode			: Int
	Field mCulling				: Bool
	Field mDepthWrite			: Bool
	Field mCastShadows		: Bool
	Field mTextureMatrix	: Float[16]
End
