Strict

Private
Import material
Import math3d
Import mesh
Import renderer
Import stats
Import world

Public
Import entity

Class Model Extends Entity Final 'Implements IMaterialDelegate Final
	Method New(mesh:Mesh, parent:Entity = Null)
		Super.New(parent)
		mMesh = mesh
		mMaterials = New Material[mMesh.NumSurfaces]
		For Local i:Int = 0 Until mMaterials.Length
			mMaterials[i] = New Material(mMesh.Material(i))', Self)
		Next
		mAnimMatrices = New Mat4[mesh.NumBones]
		For Local i:Int = 0 Until mAnimMatrices.Length
			mAnimMatrices[i] = Mat4.Create()
		Next
		Visible = True
		Active = True
	End
	
	Method Mesh:Mesh() Property
		Return mMesh
	End
	
	Method AnimSpeed:Float() Property
		Return mAnimSpeed
	End
	
	Method AnimSpeed:Void(speed:Float) Property
		mAnimSpeed = speed
	End
	
	Method AnimTime:Float() Property
		Return mCurrentFrame / mMesh._AnimSpeed
	End
	
	Method Active:Bool() Property
		Return Super.Active
	End
	
	Method Active:Void(active:Bool) Property
		If active <> Super.Active
			Super.Active(active)
			
			'Only animated models need to care about updating
			If mAnimMatrices.Length > 0 Then World._EntityNeedsUpdate(Self, active)
		End
	End
	
	Method Visible:Bool() Property
		Return Super.Visible
	End
	
	Method Visible:Void(visible:Bool) Property
		If visible <> Super.Visible
			Super.Visible(visible)
			World._EntitySetVisible(Self, visible)
			#Rem
			If visible
				For Local i:Int = 0 Until mMesh.NumSurfaces
					World._AddSurfaceToRenderList(mMesh.Surface(i), _Transform, mAnimMatrices, mMaterials[i])
				Next
			Else
				For Local i:Int = 0 Until mMesh.NumSurfaces
					World._RemoveSurfaceFromRenderList(mMesh.Surface(i), _Transform, mAnimMatrices, mMaterials[i])
				Next
			End
			#End
		End
	End
	
	Method Width:Float() Property
		Return mMesh.Width * ScaleX
	End
	
	Method Height:Float() Property
		Return mMesh.Height * ScaleY
	End
	
	Method Depth:Float() Property
		Return mMesh.Depth * ScaleZ
	End
	
	Method NumMaterials:Int() Property
		Return mMaterials.Length
	End
	
	Method Material:Material(index:Int)
		Return mMaterials[index]
	End
	
	Method Material:Material() Property
		Return Material(0)
	End
	
	Method BoxMinX:Float() Property
		Return WorldX + mMesh.BoxMinX * ScaleX
	End
	
	Method BoxMinY:Float() Property
		Return WorldY + mMesh.BoxMinY * ScaleY
	End
	
	Method BoxMinZ:Float() Property
		Return WorldZ + mMesh.BoxMinZ * ScaleZ
	End
	
	Method BoxMaxX:Float() Property
		Return WorldX + mMesh.BoxMaxX * ScaleX
	End
	
	Method BoxMaxY:Float() Property
		Return WorldY + mMesh.BoxMaxY * ScaleY
	End
	
	Method BoxMaxZ:Float() Property
		Return WorldZ + mMesh.BoxMaxZ * ScaleZ
	End
	
	#Rem
	Method MaterialChanged:Void(mat:Material)
		Local index:Int = -1
		For Local i:Int = 0 Until mMaterials.Length
			If mMaterials[i] = mat Then index = i; Exit
		Next
		If index <> -1
			World._RemoveSurfaceFromRenderList(mMesh.Surface(index), _Transform)
			If Visible Then World._AddSurfaceToRenderList(mMesh.Surface(index), _Transform, mat)
		End
	End
	#End
	
	Method _Update:Void()
		If mAnimSpeed <> 0 And mAnimMatrices.Length > 0
			mCurrentFrame += mAnimSpeed * mMesh._AnimSpeed * Stats.DeltaTime()
			If mCurrentFrame > mMesh._NumFrames Then mCurrentFrame -= mMesh._NumFrames
			If mCurrentFrame < 0 Then mCurrentFrame += mMesh._NumFrames
			mMesh.Animate(mAnimMatrices, mCurrentFrame)
		End
	End
	
	Method _Render:Int(step_:Int)
		Local numRenders:Int = 0
		Super._Render(step_)
		Renderer.SetSkinned(mAnimMatrices.Length > 0)
		If mAnimMatrices.Length() > 0 Then Renderer.SetBoneMatrices(mAnimMatrices)
		For Local i:Int = 0 Until mMesh.NumSurfaces
			If mMaterials[i]._Prepare(step_) Then mMesh.Surface(i)._Render(); numRenders += 1
		Next
		Return numRenders
	End
Private
	Field mMesh			: Mesh
	Field mMaterials	: Material[]
	Field mAnimMatrices	: Mat4[]
	Field mAnimSpeed	: Float
	Field mCurrentFrame	: Float
	
	Method New()
	End
End
