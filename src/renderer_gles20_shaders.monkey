Strict

Const STD_VERTEX_SHADER:String = "#ifdef GL_ES~nprecision highp int;~nprecision mediump float;~n#endif~n~nuniform mat4 mvp;~nuniform mat4 modelView;~nuniform mat4 normalMatrix;~nuniform mat4 invView;~nuniform int baseTexMode;~nuniform bool useNormalTex;~nuniform bool useReflectTex;~nuniform bool useRefractTex;~nuniform bool usePixelLighting;~nuniform bool lightingEnabled;~nuniform bool lightEnabled[MAX_LIGHTS];~nuniform vec4 lightPos[MAX_LIGHTS]; // In viewer space !!!~nuniform vec3 lightColor[MAX_LIGHTS];~nuniform float lightAttenuation[MAX_LIGHTS];~nuniform vec4 baseColor;~nuniform vec3 ambient;~nuniform int shininess;~nuniform float refractCoef;~nuniform bool fogEnabled;~nuniform vec2 fogDist;~nuniform bool skinned;~nuniform mat4 bones[MAX_BONES];~nattribute vec3 vpos;~nattribute vec3 vnormal;~nattribute vec3 vtangent;~nattribute vec4 vcolor;~nattribute vec2 vtex;~nattribute vec4 vboneIndices;~nattribute vec4 vboneWeights;~nvarying vec3 fpos;~nvarying vec3 fposNorm;~nvarying vec3 fnormal;~nvarying vec4 fcolor;~nvarying vec2 ftex;~nvarying vec3 fcombinedSpecular;~nvarying float fogFactor;~nvarying vec3 fcubeCoords;~nvarying vec3 freflectCoords;~nvarying vec3 frefractCoords;~nvarying mat3 tbnMatrix;~n~nvoid CalcLighting(vec3 V, vec3 NV, vec3 N) {~n // Color that combines diffuse component of all lights~n vec3 combinedColor = ambient;~n~n // Compute all lights~n for ( int i = 0; i < MAX_LIGHTS; i++ ) {~n  if ( lightEnabled[i] ) {~n   vec3 L = vec3(lightPos[i]);~n   float att = 1.0;~n~n   // Point light~n   if ( lightPos[i].w == 1.0 ) {~n    L -= V;~n    att = 1.0 / (1.0 + lightAttenuation[i]*length(L));~n   }~n~n   L = normalize(L);~n   float NdotL = max(dot(N, L), 0.0);~n~n   // Diffuse~n   combinedColor += NdotL * lightColor[i] * att;~n~n   // Specular~n   if ( shininess > 0 && NdotL > 0.0 ) {~n    vec3 H = normalize(L - NV);~n    float NdotH = max(dot(N, H), 0.0);~n    fcombinedSpecular += pow(NdotH, float(shininess)) * att;~n   }~n  }~n }~n~n fcolor *= vec4(clamp(combinedColor, 0.0, 1.0), 1.0);~n}~n~nvoid main() {~n vec4 vpos4 = vec4(vpos, 1);~n ~n // Skinning of vertex~n if ( skinned ) {~n  vec4 blendVertex = vec4(0,0,0,0);~n  for ( int i = 0; i < 4; ++i )~n   if ( int(vboneIndices[i]) > -1 ) blendVertex = ((bones[int(vboneIndices[i])] * vpos4) * vboneWeights[i]) + blendVertex;~n  vpos4 = blendVertex;~n };~n ~n // Vertex position in projection space~n gl_Position = mvp * vpos4;~n ~n // Fragment color~n fcolor = baseColor * vcolor;~n~n // Fragment texture coords~n ftex = vtex;~n ~n // Calculate vectors used in lighting and env mapping~n vec3 V;~n vec3 NV;~n vec3 N;~n if ( lightingEnabled || baseTexMode == 2 || useNormalTex || useReflectTex || useRefractTex || fogEnabled ) {~n  // Calculate vertex in viewer space~n  V = vec3(modelView * vpos4);~n~n  if ( lightingEnabled || baseTexMode == 2 || useNormalTex || useReflectTex || useRefractTex ) {~n   // Calculate normalized vertex coordinates~n   NV = normalize(V);~n~n   // Calculate normal in viewer space~n   N = normalize(vec3(normalMatrix * vec4(vnormal, 0.0)));~n  }~n }~n ~n // Lighting~n if ( lightingEnabled ) {~n  if ( !usePixelLighting && !useNormalTex ) {~n   // Color that combines specular component of all lights~n   fcombinedSpecular = vec3(0.0, 0.0, 0.0);~n  ~n   // Calculate lighting~n   CalcLighting(V, NV, N);~n  } else {~n   fpos = V;~n   fposNorm = NV;~n   fnormal = N;~n  }~n }~n ~n // Fog~n if ( fogEnabled ) fogFactor = clamp((fogDist[1] - abs(V.z)) / (fogDist[1] - fogDist[0]), 0.0, 1.0);~n ~n // Cube mapping coordinates~n if ( baseTexMode == 2 || useReflectTex || useRefractTex ) {~n  if ( baseTexMode == 2 ) fcubeCoords = vec3(invView * vec4(V, 1));~n  if ( useReflectTex ) freflectCoords = normalize(vec3(invView * vec4(reflect(NV, N), 0)));~n  if ( useRefractTex ) frefractCoords = normalize(vec3(invView * vec4(refract(NV, N, refractCoef), 0)));~n }~n ~n // Calculate TBN matrix~n if ( lightingEnabled && useNormalTex ) {~n  vec3 eyeTangent = normalize(vec3(normalMatrix * vec4(vtangent, 0)));~n  vec3 eyeBitangent = cross(eyeTangent, N);~n  tbnMatrix = mat3(eyeTangent, eyeBitangent, N);~n }~n}"
Const STD_FRAGMENT_SHADER:String = "#ifdef GL_ES~nprecision highp int;~nprecision mediump float;~n#endif~n~nuniform int baseTexMode;~nuniform bool useNormalTex;~nuniform bool useReflectTex;~nuniform bool useRefractTex;~nuniform sampler2D baseTexSampler;~nuniform samplerCube baseCubeSampler;~nuniform sampler2D normalTexSampler;~nuniform samplerCube reflectCubeSampler;~nuniform samplerCube refractCubeSampler;~nuniform bool usePixelLighting;~nuniform bool lightingEnabled;~nuniform bool lightEnabled[MAX_LIGHTS];~nuniform vec4 lightPos[MAX_LIGHTS]; // In viewer space !!!~nuniform vec3 lightColor[MAX_LIGHTS];~nuniform float lightAttenuation[MAX_LIGHTS];~nuniform vec3 ambient;~nuniform int shininess;~nuniform bool fogEnabled;~nuniform vec3 fogColor;~nvarying vec3 fpos;~nvarying vec3 fposNorm;~nvarying vec3 fnormal;~nvarying vec4 fcolor;~nvarying vec2 ftex;~nvarying vec3 fcombinedSpecular;~nvarying float fogFactor;~nvarying vec3 fcubeCoords;~nvarying vec3 freflectCoords;~nvarying vec3 frefractCoords;~nvarying mat3 tbnMatrix;~n~nvec4 combinedColor;~nvec3 combinedSpecular;~n~nvoid CalcLighting(vec3 V, vec3 NV, vec3 N) {~n // Color that combines diffuse component of all lights~n combinedColor = vec4(ambient, 1.0);~n ~n // Get vertex normal or compute from normal map~n vec3 normal = N;~n if ( useNormalTex ) {~n  vec3 normalTexColor = vec3(texture2D(normalTexSampler, ftex));~n  normal = tbnMatrix * (normalTexColor*2.0 - 1.0);~n }~n~n // Compute all lights~n for ( int i = 0; i < MAX_LIGHTS; i++ ) {~n  if ( lightEnabled[i] ) {~n   vec3 L = vec3(lightPos[i]);~n   float att = 1.0;~n~n   // Point light~n   if ( lightPos[i].w == 1.0 ) {~n    L -= V;~n    att = 1.0 / (1.0 + lightAttenuation[i]*length(L));~n   }~n~n   L = normalize(L);~n   float NdotL = max(dot(normal, L), 0.0);~n~n   // Diffuse~n   combinedColor += NdotL * vec4(lightColor[i], 1.0) * att;~n~n   // Specular~n   if ( shininess > 0 && NdotL > 0.0 ) {~n    vec3 H = normalize(L - NV);~n    float NdotH = max(dot(normal, H), 0.0);~n    combinedSpecular += pow(NdotH, float(shininess)) * att;~n   }~n  }~n }~n ~n combinedColor = clamp(combinedColor, 0.0, 1.0);~n}~n~nvoid main() {~n // Lighting~n if ( lightingEnabled && (usePixelLighting || useNormalTex) ) {~n  CalcLighting(fpos, fposNorm, fnormal);~n  combinedColor *= fcolor;~n } else {~n  combinedColor = fcolor;~n }~n~n // Base texture~n if ( baseTexMode == 1 ) combinedColor *= texture2D(baseTexSampler, ftex);~n else if ( baseTexMode == 2 ) combinedColor *= textureCube(baseCubeSampler, fcubeCoords);~n~n // Reject fragment with low alpha~n if ( combinedColor.a <= 0.004 ) discard;~n ~n // Reflection texture~n if ( useReflectTex ) {~n  combinedColor *= textureCube(reflectCubeSampler, freflectCoords);~n }~n~n // Refraction texture~n if ( useRefractTex ) {~n  combinedColor *= textureCube(refractCubeSampler, frefractCoords);~n }~n~n // Add specular~n if ( lightingEnabled ) {~n  if ( usePixelLighting || useNormalTex ) combinedColor += vec4(combinedSpecular, 0.0);~n  else combinedColor += vec4(fcombinedSpecular, 0.0);~n  combinedColor = clamp(combinedColor, 0.0, 1.0);~n }~n ~n // Add fog~n if ( fogEnabled ) combinedColor = vec4(mix(fogColor, vec3(combinedColor), fogFactor), combinedColor.a);~n ~n // Set final color~n gl_FragColor = combinedColor;~n}~n"
Const _2D_VERTEX_SHADER:String = "#ifdef GL_ES~nprecision highp int;~nprecision mediump float;~n#endif~n~nuniform mat4 mvp;~nattribute vec3 vpos;~nattribute vec2 vtex;~nvarying vec2 ftex;~n~nvoid main() {~n gl_Position = mvp * vec4(vpos, 1.0);~n    ftex = vtex;~n}"
Const _2D_FRAGMENT_SHADER:String = "#ifdef GL_ES~nprecision highp int;~nprecision mediump float;~n#endif~n~nuniform int baseTexMode;~nuniform sampler2D baseTexSampler;~nuniform vec4 baseColor;~nvarying vec2 ftex;~n~nvoid main() {~n // Base color~n gl_FragColor = baseColor;~n~n // Base texture~n if ( baseTexMode == 1 ) gl_FragColor *= texture2D(baseTexSampler, vec2(ftex.x, ftex.y));~n}"
