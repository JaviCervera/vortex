Strict

Private
Import collision
Import listener
Import material
Import math3d
Import mojo.audio
Import renderer
Import world

Public
Class Entity
	Const COLLISION_NONE	: Int = 0
	Const COLLISION_SPHERE	: Int = 1
	Const COLLISION_BOX		: Int = 2

	Method New(parent:Entity = Null)
		Parent = parent
		mChildren = New List<Entity>
		mActive = False		'Subclases should change this if needed
		mVisible = False	'Subclases should change this if needed
		mPosition = Vec3.Create()
		mRotation = Vec3.Create()
		mScale = Vec3.Create(1, 1, 1)
		mTransform = Mat4.Create()
		World._AddEntity(Self)
		_UpdateTransform()
	End
	
	Method Discard:Void()
		Visible = False
		While Not mChildren.IsEmpty()
			mChildren.First().Discard()
		Wend
		Parent = Null
		World._FreeEntity(Self)
	End
	
	Method Name:String() Property
		Return mName
	End
	
	Method Name:Void(name:String) Property
		mName = name
	End
	
	Method Parent:Entity() Property
		Return mParent
	End
	
	Method Parent:Void(p:Entity) Property
		If mParent <> p
			If mParent Then mParent.mChildren.RemoveFirst(Self)
			If p Then p.mChildren.AddLast(Self)
			mParent = p
		End
	End
	
	Method NumChildren:Int() Property
		Return mChildren.Count()
	End
	
	Method Child:Entity(index:Int)
		Local current:Int = 0
		For Local e:Entity = Eachin mChildren
			If current = index Then Return e
			current += 1
		Next
		Return Null
	End
	
	Method Active:Bool() Property
		Return mActive
	End
	
	Method Active:Void(active:Bool) Property
		mActive = active
		For Local c:Entity = Eachin mChildren
			c.Active = active
		Next
	End
	
	Method Visible:Bool() Property
		Return mVisible
	End
	
	Method Visible:Void(visible:Bool) Property
		mVisible = visible
		For Local c:Entity = Eachin mChildren
			c.Visible = visible
		Next
	End
	
	Method X:Float() Property
		Return mPosition.X
	End
	
	Method Y:Float() Property
		Return mPosition.Y
	End
	
	Method Z:Float() Property
		Return mPosition.Z
	End
	
	Method X:Void(val:Float) Property
		mPosition.X = val
		_UpdateTransform()
	End
	
	Method Y:Void(val:Float) Property
		mPosition.Y = val
		_UpdateTransform()
	End
	
	Method Z:Void(val:Float) Property
		mPosition.Z = val
		_UpdateTransform()
	End
	
	Method WorldX:Float() Property
		Return mTransform.M[12]
	End
	
	Method WorldY:Float() Property
		Return mTransform.M[13]
	End
	
	Method WorldZ:Float() Property
		Return mTransform.M[14]
	End
	
	Method SetPosition:Void(x:Float, y:Float, z:Float)
		mPosition.Set(x, y, z)
		_UpdateTransform()
	End
	
	Method Move:Void(x:Float, y:Float, z:Float, collideWithEntities:Bool = True)
		'Transform x, y, z by entity's rotation
		mTempQuat.SetEuler(mRotation.X, mRotation.Y, mRotation.Z)
		mTempQuat.Mul(x, y, z)
		
		'Add resulting vector to entity's position
		'mTempVec.Set(mPosition)
		mTempVec.Set(mTempQuat.ResultVector())
		
		If CollisionMode <> COLLISION_NONE And Active
			'Reset collision status
			mCollided = False
			mCollidedEntity = Null
			
			'Check static collisions
			If World._CheckStaticCollision(WorldX + mTempVec.X, WorldY, WorldZ, mSqRadius) Then mCollided = True; mTempVec.X = 0
			If World._CheckStaticCollision(WorldX, WorldY + mTempVec.Y, WorldZ, mSqRadius) Then mCollided = True; mTempVec.Y = 0
			If World._CheckStaticCollision(WorldX, WorldY, WorldZ + mTempVec.Z, mSqRadius) Then mCollided = True; mTempVec.Z = 0
			
			'Check collisions with other entities
			If collideWithEntities
				For Local other:Entity = Eachin World._Entities()
					'Do not check collisions with itself
					If other <> Self And other.CollisionMode <> COLLISION_NONE And other.Active
						If CollisionMode = COLLISION_SPHERE And other.CollisionMode = COLLISION_SPHERE
							If Collision.SphereSphere(WorldX + mTempVec.X, WorldY, WorldZ, mSqRadius, other.WorldX, other.WorldY, other.WorldZ, other.mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.X = 0
							End
							If Collision.SphereSphere(WorldX, WorldY + mTempVec.Y, WorldZ, mSqRadius, other.WorldX, other.WorldY, other.WorldZ, other.mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.Y = 0
							End
							If Collision.SphereSphere(WorldX, WorldY, WorldZ + mTempVec.Z, mSqRadius, other.WorldX, other.WorldY, other.WorldZ, other.mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.Z = 0
							End
						Elseif CollisionMode = COLLISION_SPHERE And other.CollisionMode = COLLISION_BOX
							If Collision.BoxSphere(other.BoxMinX, other.BoxMinY, other.BoxMinZ, other.BoxMaxX, other.BoxMaxY, other.BoxMaxZ, WorldX + mTempVec.X, WorldY, WorldZ, mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.X = 0
							End
							If Collision.BoxSphere(other.BoxMinX, other.BoxMinY, other.BoxMinZ, other.BoxMaxX, other.BoxMaxY, other.BoxMaxZ, WorldX, WorldY + mTempVec.Y, WorldZ, mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.Y = 0
							End
							If Collision.BoxSphere(other.BoxMinX, other.BoxMinY, other.BoxMinZ, other.BoxMaxX, other.BoxMaxY, other.BoxMaxZ, WorldX, WorldY, WorldZ + mTempVec.Z, mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.Z = 0
							End
						Elseif CollisionMode = COLLISION_BOX And other.CollisionMode = COLLISION_SPHERE
							If Collision.BoxSphere(BoxMinX + mTempVec.X, BoxMinY, BoxMinZ, BoxMaxX + mTempVec.X, BoxMaxY, BoxMaxZ, other.WorldX, other.WorldY, other.WorldZ, other.mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.X = 0
							End
							If Collision.BoxSphere(BoxMinX, BoxMinY + mTempVec.Y, BoxMinZ, BoxMaxX, BoxMaxY + mTempVec.Y, BoxMaxZ, other.WorldX, other.WorldY, other.WorldZ, other.mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.Y = 0
							End
							If Collision.BoxSphere(BoxMinX, BoxMinY, BoxMinZ + mTempVec.Z, BoxMaxX, BoxMaxY, BoxMaxZ + mTempVec.Z, other.WorldX, other.WorldY, other.WorldZ, other.mSqRadius)
								mCollided = True
								mCollidedEntity = other
								mTempVec.Z = 0
							End
						Elseif CollisionMode = COLLISION_BOX And other.CollisionMode = COLLISION_BOX
							If Collision.BoxBox(BoxMinX + mTempVec.X, BoxMinY, BoxMinZ, BoxMaxX + mTempVec.X, BoxMaxY, BoxMaxZ, other.BoxMinX, other.BoxMinY, other.BoxMinZ, other.BoxMaxX, other.BoxMaxY, other.BoxMaxZ)
								mCollided = True
								mCollidedEntity = other
								mTempVec.X = 0
							End
							If Collision.BoxBox(BoxMinX, BoxMinY + mTempVec.Y, BoxMinZ, BoxMaxX, BoxMaxY + mTempVec.Y, BoxMaxZ, other.BoxMinX, other.BoxMinY, other.BoxMinZ, other.BoxMaxX, other.BoxMaxY, other.BoxMaxZ)
								mCollided = True
								mCollidedEntity = other
								mTempVec.Y = 0
							End
							If Collision.BoxBox(BoxMinX, BoxMinY, BoxMinZ + mTempVec.Z, BoxMaxX, BoxMaxY, BoxMaxZ + mTempVec.Z, other.BoxMinX, other.BoxMinY, other.BoxMinZ, other.BoxMaxX, other.BoxMaxY, other.BoxMaxZ)
								mCollided = True
								mCollidedEntity = other
								mTempVec.Z = 0
							End
						End
						
						'If it has collided with an entity, do not check for more collisions
						If mCollidedEntity <> Null Then Exit
					End
				Next
			End
		End
		
		'Go to destination point
		mPosition.Sum(mTempVec)
		
		_UpdateTransform()
	End
	
	Method Pitch:Float() Property
		Return mRotation.X
	End
	
	Method Yaw:Float() Property
		Return mRotation.Y
	End
	
	Method Roll:Float() Property
		Return mRotation.Z
	End
	
	Method Pitch:Void(val:Float) Property
		mRotation.X = val
		_UpdateTransform()
	End
	
	Method Yaw:Void(val:Float) Property
		mRotation.Y = val
		_UpdateTransform()
	End
	
	Method Roll:Void(val:Float) Property
		mRotation.Z = val
		_UpdateTransform()
	End
	
	Method SetRotation:Void(pitch:Float, yaw:Float, roll:Float)
		mRotation.Set(pitch, yaw, roll)
		_UpdateTransform()
	End
	
	Method Turn:Void(pitch:Float, yaw:Float, roll:Float)
		mRotation.Sum(pitch, yaw, roll)
		_UpdateTransform()
	End
	
	Method Width:Float() Property
		Return mScale.X
	End
	
	Method Height:Float() Property
		Return mScale.Y
	End
	
	Method Depth:Float() Property
		Return mScale.Z
	End
	
	Method ScaleX:Float() Property
		Return mScale.X
	End
	
	Method ScaleY:Float() Property
		Return mScale.Y
	End
	
	Method ScaleZ:Float() Property
		Return mScale.Z
	End
	
	Method ScaleX:Void(val:Float) Property
		mScale.X = val
		_UpdateTransform()
	End
	
	Method ScaleY:Void(val:Float) Property
		mScale.Y = val
		_UpdateTransform()
	End
	
	Method ScaleZ:Void(val:Float) Property
		mScale.Z = val
		_UpdateTransform()
	End

	Method SetScale:Void(x:Float, y:Float, z:Float)
		mScale.Set(x, y, z)
		_UpdateTransform()
	End
	
	Method CollisionMode:Int() Property
		Return mCollisionMode
	End
	
	Method CollisionMode:Void(mode:Int) Property
		mCollisionMode = mode
	End

	Method Radius:Float() Property
		Return mRadius
	End
	
	Method Radius:Void(rad:Float) Property
		mRadius = rad
		mSqRadius = rad * rad
	End
	
	Method Collided:Bool() Property
		Return mCollided
	End
	
	Method CollidedEntity:Entity() Property
		Return mCollidedEntity
	End
	
	Method Distance:Float(other:Entity)
		mTempVec.Set(mPosition)
		mTempVec.Sub(other.mPosition)
		Return mTempVec.Length()
	End
	
	Method NumMaterials:Int() Property
		Return 0
	End
	
	Method Material:Material(index:Int)
		Return Null
	End
	
	Method Material:Material() Property
		Return Material(0)
	End
	
	Method ReplaceMaterials:Void(mat:Material)
		For Local i:Int = 0 Until NumMaterials
			Material(i).Set(mat)
		Next
	End
	
	Method EmitSound:Void(sound:Sound, radius:Float, channel:Int)
		Listener._EmitSound(Self, sound, radius, channel)
	End
	
	Method BoxMinX:Float() Property
		Return WorldX - Width/2
	End
	
	Method BoxMinY:Float() Property
		Return WorldY - Height/2
	End
	
	Method BoxMinZ:Float() Property
		Return WorldZ - Depth/2
	End
	
	Method BoxMaxX:Float() Property
		Return WorldX - Width/2
	End
	
	Method BoxMaxY:Float() Property
		Return WorldY - Height/2
	End
	
	Method BoxMaxZ:Float() Property
		Return WorldZ - Depth/2
	End
	
	Method UserData:Object() Property
		Return mUserData
	End
	
	Method UserData:Void(data:Object) Property
		mUserData = data
	End
	
	Method _Update:Void()
	End
	
	Method _PrepareForRender:Void()
	End
	
	Method _Render:Int(step_:Int)
		Renderer.SetModelMatrix(mTransform)
		Return 0
	End
	
	Method _Transform:Mat4() Property
		Return mTransform
	End
Private
	Field mName				: String
	Field mParent			: Entity
	Field mChildren			: List<Entity>
	Field mActive			: Bool
	Field mVisible			: Bool
	Field mPosition			: Vec3
	Field mRotation			: Vec3
	Field mScale			: Vec3
	Field mTransform		: Mat4
	Field mCollisionMode	: Int
	Field mRadius			: Float
	Field mSqRadius			: Float
	Field mCollided			: Bool
	Field mCollidedEntity	: Entity
	Field mUserData			: Object
	
	Method _UpdateTransform:Void()
		'Set entity's transform
		mTransform.SetTransform(mPosition, mRotation, mScale)
		
		'Premultiply paren't transform
		If mParent
			mTempMat.Set(mParent.mTransform)
			mTempMat.Mul(mTransform)
			mTransform.Set(mTempMat)
		End
		
		'Update children's transforms
		For Local child:Entity = Eachin mChildren
			child._UpdateTransform()
		Next
	End
	
	Global mTempMat		: Mat4 = Mat4.Create()
	Global mTempQuat	: Quat = Quat.Create()
	Global mTempVec		: Vec3 = Vec3.Create()
End
