#OPENGL_DEPTH_BUFFER_ENABLED=True

Strict

Private

Import brl.databuffer
Import color
Import math3d
Import mojo.app
Import mojo.graphics
Import opengl.gles20
Import renderer_shaders
Import shader

'#If TARGET="html5"
Const GLSL_VERSION : String = ""
'#Else
'Const GLSL_VERSION:String = "#version 120~n"
'#EndIf

Public

Class RendererState Final
	Field ProjectionMatrix	: Mat4
	Field ViewMatrix				: Mat4
	Field ModelMatrix				: Mat4
	Field InverseViewMatrix	: Mat4
	Field DepthBiasMatrix		: Mat4
	Field TextureMatrix			: Mat4
	Field BoneMatrices			: Mat4[]
	Field Skinned						: Bool
	Field BlendMode					: Int
	Field Color							: Int
	Field Ambient						: Int
	Field Shininess					: Float
	Field FogEnabled				: Bool
	Field FogColor					: Int
	Field FogMinDistance		: Float
	Field FogMaxDistance		: Float
	Field ShadowsEnabled		: Bool
	Field DepthEpsilon			: Float
	Field RefractCoef				: Float
	Field PixelLighting			: Bool
	Field NumLights					: Int
	Field LightPos					: Vec3[]
	Field LightW						: Float[]
	Field LightColor				: Int[]
	Field LightRadius				: Float[]
	Field BaseTexMode				: Int
	Field UseNormalTex			: Bool
	Field UseLightTex				: Bool
	Field UseReflectTex			: Bool
	Field UseRefractTex			: Bool
	
	Method New(maxLights:Int)
		ProjectionMatrix = Mat4.Create()
		ViewMatrix = Mat4.Create()
		ModelMatrix = Mat4.Create()
		InverseViewMatrix = Mat4.Create()
		DepthBiasMatrix = Mat4.Create()
		TextureMatrix = Mat4.Create()
		LightPos = New Vec3[maxLights]
		For Local i:Int = 0 Until maxLights
			LightPos[i] = Vec3.Create()
		Next
		LightW = New Float[maxLights]
		LightColor = New Int[maxLights]
		LightRadius = New Float[maxLights]
		Color = color.Color.WHITE
	End
End

Class Renderer Final
Public
	Const STEP_SHADOWS:Int = 0			'Shadow render
	Const STEP_SOLID:Int = 1			'Solid blend with depth writing
	Const STEP_DEPTHWRITE:Int = 2		'Other blends with depth writing
	Const STEP_NODEPTHWRITE:Int = 3		'All entitites with no depth writing
	Const STEP_COUNT:Int = 4

	Const BLEND_SOLID:Int = 0
	Const BLEND_ALPHA:Int = 1
	Const BLEND_ADD:Int = 2
	Const BLEND_MUL:Int = 3
	
	Const FILTER_NONE:Int = 0
	Const FILTER_LINEAR:Int = 1
	Const FILTER_BILINEAR:Int = 2
	Const FILTER_TRILINEAR:Int = 3
	
	'Const TEXTURE_DISABLED:Int = 0
	'Const TEXTURE_2D:Int = 1
	
	Const BASETEX_UNIT:Int = 0
	Const BASECUBE_UNIT:Int = 1
	Const NORMALTEX_UNIT:Int = 2
	Const LIGHTMAP_UNIT:Int = 3
	Const REFLECTTEX_UNIT:Int = 4
	Const REFRACTTEX_UNIT:Int = 5
	Const DEPTHTEX_UNIT:Int = 6
	
	Const ELLIPSEPOINTS:Int = 64

	'---------------------------------------------------------------------------
	'Setup
	'---------------------------------------------------------------------------

	Function Init:Bool(numLights:Int, numBones:Int)
		'Create renderer state
		mState = New RendererState(numLights)
	
		'Set the max number of lights and bones supported
		mMaxLights = numLights
		mMaxBones = numBones
	
		'Get GL and GLSL versions
		mVendor = glGetString(GL_VENDOR)
		mRenderer = glGetString(GL_RENDERER)
		mVersionStr = glGetString(GL_VERSION)
		mShadingVersionStr = glGetString(GL_SHADING_LANGUAGE_VERSION)
#If LANG = "js"
		Local glVersionStr:String[] = mVersionStr.Split(" ")
		Local glslVersionStr:String[] = mShadingVersionStr.Split(" ")
		mVersion = Float(glVersionStr[glVersionStr.Length() - 1])
		mShadingVersion = Float(glslVersionStr[glslVersionStr.Length() - 1])
#Else
		mVersion = Float(mVersionStr.Split(" ")[0])
		mShadingVersion = Float(mShadingVersionStr.Split(" ")[0])
#End

		'Create default shader
		mDefaultShader = New Shader(STD_VERTEX_SHADER, STD_FRAGMENT_SHADER)
		If mDefaultShader.Handle = 0 Then Return False
		
		'Create depth shader
		mDepthShader = New Shader(DEPTH_VERTEX_SHADER, DEPTH_FRAGMENT_SHADER)
		If mDepthShader.Handle = 0 Then Return False
		
		'Create 2D shader
		m2DShader = New Shader(_2D_VERTEX_SHADER, _2D_FRAGMENT_SHADER)
		If m2DShader.Handle = 0 Then Return False
		
		'Use default shader
		mActiveShader = mDefaultShader
		
		'Delete old buffers if they exist
		If mEllipseBuffer <> 0 Then FreeBuffer(mEllipseBuffer)
		If mLineBuffer <> 0 Then FreeBuffer(mLineBuffer)
		If mRectBuffer <> 0 Then FreeBuffer(mRectBuffer)

		'Create ellipse buffer
		Local dataBuffer:DataBuffer = New DataBuffer(ELLIPSEPOINTS*12, True)
		Local inc:Float = 360.0 / ELLIPSEPOINTS
		For Local i:Int = 0 Until ELLIPSEPOINTS
			Local x:Float = 0.5 + 0.5 * Cos(i * inc)
			Local y:Float = 0.5 + 0.5 * Sin(i * inc)
			dataBuffer.PokeFloat(i*12, x)
			dataBuffer.PokeFloat(i*12 + 4, y)
			dataBuffer.PokeFloat(i*12 + 8, 0)
		Next
		mEllipseBuffer = CreateVertexBuffer(dataBuffer.Length)
		SetVertexBufferData(mEllipseBuffer, 0, dataBuffer.Length, dataBuffer)
		dataBuffer.Discard()
		
		'Create line buffer
		dataBuffer = New DataBuffer(24, True)
		dataBuffer.PokeFloat(0, 0)
		dataBuffer.PokeFloat(4, 0)
		dataBuffer.PokeFloat(8, 0)
		dataBuffer.PokeFloat(12, 1)
		dataBuffer.PokeFloat(16, 1)
		dataBuffer.PokeFloat(20, 0)
		mLineBuffer = CreateVertexBuffer(dataBuffer.Length)
		SetVertexBufferData(mLineBuffer, 0, dataBuffer.Length, dataBuffer)
		dataBuffer.Discard()
		
		'Create rect buffer
		dataBuffer = New DataBuffer(80, True)
		dataBuffer.PokeFloat(0, 0)
		dataBuffer.PokeFloat(4, 0)
		dataBuffer.PokeFloat(8, 0)
		dataBuffer.PokeFloat(12, 1)
		dataBuffer.PokeFloat(16, 0)
		dataBuffer.PokeFloat(20, 0)
		dataBuffer.PokeFloat(24, 1)
		dataBuffer.PokeFloat(28, 1)
		dataBuffer.PokeFloat(32, 0)
		dataBuffer.PokeFloat(36, 0)
		dataBuffer.PokeFloat(40, 1)
		dataBuffer.PokeFloat(44, 0)
		mRectBuffer = CreateVertexBuffer(dataBuffer.Length)
		SetVertexBufferData(mRectBuffer, 0, dataBuffer.Length, dataBuffer)
		dataBuffer.Discard()
		
		'Default framebuffer height
		mFramebufferHeight = DeviceHeight()

		Return True
	End
	
	Function State:RendererState()
		Return mState
	End

	Function Setup2D:Void(x:Int, y:Int, w:Int, h:Int)
		Local fbHeight:Int = mFramebufferHeight
		If fbHeight = 0 Then fbHeight = DeviceHeight()
	
		'Switch to 2D shader
		mActiveShader = m2DShader

		'Disable 3D states
		SetCulling(False)
		glDisable(GL_DEPTH_TEST)
		'glBindTexture(GL_TEXTURE_2D, 0)

		'Setup 2D
		glEnable(GL_BLEND)
		glEnable(GL_SCISSOR_TEST)
		glFrontFace(GL_CCW)
		SetBlendMode(BLEND_ALPHA)
		SetColor(Color.WHITE)

		'Setup viewport
		y = fbHeight - y - h
		glViewport(x, y, w, h)
		glScissor(x, y, w, h)

		'Setup matrices
		mTempMatrix.SetIdentity()
		mTempMatrix.SetOrthoLH(0, w, h, 0, 0, 100)
		Renderer.SetProjectionMatrix(mTempMatrix)
		mTempMatrix.SetIdentity()
		Renderer.SetTextureMatrix(mTempMatrix)
		Renderer.SetViewMatrix(mTempMatrix)
		Renderer.SetModelMatrix(mTempMatrix)
	End

	Function Setup3D:Void(x:Int, y:Int, w:Int, h:Int, isDepthPass:Bool = False)
		Local fbHeight:Int = mFramebufferHeight
		If fbHeight = 0 Then fbHeight = DeviceHeight()
		
		'Switch to 3D shader
		If Not isDepthPass
			mActiveShader = mDefaultShader
		Else
			mActiveShader = mDepthShader
		End

		'Disable 2D & mojo states
		'glBindTexture(GL_TEXTURE_2D, 0)

		'Setup 3D
		glEnable(GL_BLEND)
		glEnable(GL_DEPTH_TEST)
		glEnable(GL_SCISSOR_TEST)
		glDepthFunc(GL_LEQUAL)
		SetPixelLighting(False)
		SetNumLights(0)
		SetCulling(True)
		glFrontFace(GL_CW)
		SetDepthWrite(True)
		SetBlendMode(BLEND_SOLID)
		SetColor(Color.WHITE)
		SetSkinned(False)

		'Setup viewport
		y = fbHeight - y - h
		glViewport(x, y, w, h)
		glScissor(x, y, w, h)
		
		'Setup texture matrix
		mTempMatrix.SetIdentity()
		Renderer.SetTextureMatrix(mTempMatrix)
		
		'Disable shadows by default
		Renderer.SetDepthData(mTempMatrix, mTempMatrix, 0, 0)
	End
	
	Function SetupMojo:Void()
		'Disable 3D states
		SetCulling(False)
		glDisable(GL_DEPTH_TEST)

		'Setup 2D
		glEnable(GL_BLEND)
		glEnable(GL_SCISSOR_TEST)
		glFrontFace(GL_CCW)
		SetBlendMode(BLEND_ALPHA)
		SetColor(Color.WHITE)
		
		glEnableVertexAttribArray 0 ; glVertexAttribPointer 0,2,GL_FLOAT,False,28,0
		glEnableVertexAttribArray 1 ; glVertexAttribPointer 1,2,GL_FLOAT,False,28,8
		glEnableVertexAttribArray 2 ; glVertexAttribPointer 2,2,GL_FLOAT,False,28,16
		glEnableVertexAttribArray 3 ; glVertexAttribPointer 3,4,GL_UNSIGNED_BYTE,True,28,24
	End

	Function SetProjectionMatrix:Void(m:Mat4)
		mState.ProjectionMatrix.Set(m)
	End

	Function SetViewMatrix:Void(m:Mat4)
		mState.ViewMatrix.Set(m)
		mState.InverseViewMatrix.Set(m)
		mState.InverseViewMatrix.Invert()
	End

	Function SetModelMatrix:Void(m:Mat4)
		mState.ModelMatrix.Set(m)
	End
	
	Function SetDepthData:Void(depthProj:Mat4, depthView:Mat4, depthTex:Int, depthEpsilon:Float)
		mState.DepthBiasMatrix.SetIdentity()
		mState.DepthBiasMatrix.M[0] = 0.5
		mState.DepthBiasMatrix.M[5] = 0.5
		mState.DepthBiasMatrix.M[10] = 0.5
		mState.DepthBiasMatrix.M[12] = 0.5
		mState.DepthBiasMatrix.M[13] = 0.5
		mState.DepthBiasMatrix.M[14] = 0.5
		mState.DepthBiasMatrix.Mul(depthProj)
		mState.DepthBiasMatrix.Mul(depthView)
		mState.ShadowsEnabled = (depthTex <> 0)
		mState.DepthEpsilon = depthEpsilon
	
		If depthTex <> 0
			glActiveTexture(GL_TEXTURE0 + DEPTHTEX_UNIT)
			glBindTexture(GL_TEXTURE_2D, depthTex)
			glActiveTexture(GL_TEXTURE0)
		End
	End
	
	Function SetBoneMatrices:Void(matrices:Mat4[])
		mState.BoneMatrices = matrices
	End
	
	Function MaxBones:Int()
		Return mMaxBones
	End
	
	Function SetSkinned:Void(enable:Bool)
		mState.Skinned = enable
	End

	Function SetBlendMode:Void(mode:Int)
		mState.BlendMode = mode
		Select mode
		Case BLEND_SOLID
			glBlendFunc(GL_ONE, GL_ZERO)
		Case BLEND_ALPHA
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		Case BLEND_ADD
			glBlendFunc(GL_SRC_ALPHA, GL_ONE)
		Case BLEND_MUL
			glBlendFunc(GL_DST_COLOR, GL_ZERO)
		End
	End
	
	Function SetColor:Void(color:Int)
		mState.Color = color
	End
	
	Function SetAmbient:Void(color:Int)
		mState.Ambient = color
	End

	Function SetShininess:Void(shininess:Float)
		mState.Shininess = shininess
	End
	
	Function SetFog:Void(enable:Bool, color:Int, minDist:Float, maxDist:Float)
		mState.FogEnabled = enable
		mState.FogColor = color
		mState.FogMinDistance = minDist
		mState.FogMaxDistance = maxDist
	End

	Function SetCulling:Void(enable:Bool)
		If enable Then glEnable(GL_CULL_FACE) Else glDisable(GL_CULL_FACE)
	End

	Function SetDepthWrite:Void(enable:Bool)
		glDepthMask(enable)
	End
	
	Function SetRefractCoef:Void(coef:Float)
		mState.RefractCoef = coef
	End
	
	Function SetPixelLighting:Void(enable:Bool)
		mState.PixelLighting = enable
	End

	Function SetNumLights:Void(num:Int)
		mState.NumLights = num
	End

	Function SetLight:Void(index:Int, x:Float, y:Float, z:Float, w:Float, color:Int, radius:Float)
		mState.LightPos[index].Set(x, y, z)
		mState.LightW[index] = w
		mState.LightColor[index] = color
		mState.LightRadius[index] = radius
	End
	
	Function MaxLights:Int()
		Return mMaxLights
	End

	'---------------------------------------------------------------------------
	' Drawing
	'---------------------------------------------------------------------------

	Function ClearColorBuffer:Void(color:Int = Color.BLACK)
		glClearColor(Color.Red(color) / 255.0, Color.Green(color) / 255.0, Color.Blue(color) / 255.0, Color.Alpha(color) / 255.0)
		glClear(GL_COLOR_BUFFER_BIT)
	End

	Function ClearDepthBuffer:Void()
		glClear(GL_DEPTH_BUFFER_BIT)
	End

	Function DrawPoint:Void(x:Float, y:Float)
		DrawLine(x-0.5, y-0.5, x+0.5, y+0.5)
	End

	Function DrawLine:Void(x1:Float, y1:Float, x2:Float, y2:Float)
		mTempMatrix.SetTransform(x1, y1, 0, 0, 0, 0, x2-x1, y2-y1, 1)
		SetModelMatrix(mTempMatrix)
		mActiveShader.Prepare()
		DrawBuffers(mLineBuffer, 0, 2, 0, -1, -1, -1, -1, -1, -1, -1, 0, GL_LINES)
	End
	
	Function DrawEllipse:Void(x:Float, y:Float, width:Float, height:Float)
		mTempMatrix.SetTransform(x, y, 0, 0, 0, 0, width, height, 1)
		SetModelMatrix(mTempMatrix)
		mActiveShader.Prepare()
		DrawBuffers(mEllipseBuffer, 0, ELLIPSEPOINTS, 0, -1, -1, -1, -1, -1, -1, -1, 0, GL_TRIANGLE_FAN)
	End

	Function DrawRect:Void(x:Float, y:Float, width:Float, height:Float)
		mTempMatrix.SetTransform(x, y, 0, 0, 0, 0, width, height, 1)
		SetModelMatrix(mTempMatrix)
		mActiveShader.Prepare()
		DrawBuffers(mRectBuffer, 0, 4, 0, -1, -1, -1, -1, -1, -1, -1, 0, GL_TRIANGLE_FAN)
	End
	
	Function DrawRectEx:Void(x:Float, y:Float, width:Float, height:Float, u0:Float, v0:Float, u1:Float, v1:Float)
		mTexDataBuffer.PokeFloat(0, u0)
		mTexDataBuffer.PokeFloat(4, v0)
		mTexDataBuffer.PokeFloat(8, u1)
		mTexDataBuffer.PokeFloat(12, v0)
		mTexDataBuffer.PokeFloat(16, u1)
		mTexDataBuffer.PokeFloat(20, v1)
		mTexDataBuffer.PokeFloat(24, u0)
		mTexDataBuffer.PokeFloat(28, v1)
		SetVertexBufferData(mRectBuffer, 48, mTexDataBuffer.Length(), mTexDataBuffer)
		mTempMatrix.SetTransform(x, y, 0, 0, 0, 0, width, height, 1)
		SetModelMatrix(mTempMatrix)
		mActiveShader.Prepare()
		DrawBuffers(mRectBuffer, 0, 4, 0, -1, -1, -1, 48, -1, -1, -1, 0, GL_TRIANGLE_FAN)
	End

	'---------------------------------------------------------------------------
	' Texture
	'---------------------------------------------------------------------------
	
	Function CreateTexture:Int(width:Int, height:Int)
		Local texture:Int = glCreateTexture()
		glBindTexture(GL_TEXTURE_2D, texture)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
		'glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
		'glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, Null)
		'glBindTexture(GL_TEXTURE_2D, 0)
		Return texture
	End
	
	Function CreateTexture:Int(buffer:DataBuffer, width:Int, height:Int, filter:Int)
		Local texture:Int = glCreateTexture()
		glBindTexture(GL_TEXTURE_2D, texture)
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, MagFilter(filter))
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, MinFilter(filter))
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buffer)
'#If TARGET<>"html5"
		If filter > FILTER_LINEAR Then glGenerateMipmap(GL_TEXTURE_2D)
'#EndIf
		'glBindTexture(GL_TEXTURE_2D, 0)
		Return texture
	End

	Function LoadTexture:Int(filename:String, size:Int[], filter:Int)
		'Trick to get texture size
		If size.Length >= 2
			Local img:Image = LoadImage(filename)
			If img <> Null
				size[0] = img.Width()
				size[1] = img.Height()
				img.Discard()
			Else
				size[0] = 0
				size[1] = 0
				Return 0
			End
		End
		
		'Fix filename
		If String.FromChar(filename[0]) <> "/" And String.FromChar(filename[1]) <> ":" Then filename = "cerberus://data/" + filename
		
		Local texture:Int = glCreateTexture()
		glBindTexture(GL_TEXTURE_2D, texture)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, MagFilter(filter))
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, MinFilter(filter))
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, filename)
'#If TARGET<>"html5"
		If filter > FILTER_LINEAR Then glGenerateMipmap(GL_TEXTURE_2D)
'#EndIf
		'glBindTexture(GL_TEXTURE_2D, 0)

		Return texture
	End
	
	Function LoadCubicTexture:Int(left:String, right:String, front:String, back:String, top:String, bottom:String, size:Int[], filter:Int)
		'Trick to get texture size
		If size.Length >= 2
			Local img:Image = LoadImage(left)
			If img <> Null
				size[0] = img.Width()
				size[1] = img.Height()
				img.Discard()
			Else
				size[0] = 0
				size[1] = 0
				Return 0
			End
		End
		
		'Fix filenames
		If String.FromChar(left[0]) <> "/" And String.FromChar(left[1]) <> ":" Then left = "cerberus://data/" + left
		If String.FromChar(right[0]) <> "/" And String.FromChar(right[1]) <> ":" Then right = "cerberus://data/" + right
		If String.FromChar(front[0]) <> "/" And String.FromChar(front[1]) <> ":" Then front = "cerberus://data/" + front
		If String.FromChar(back[0]) <> "/" And String.FromChar(back[1]) <> ":" Then back = "cerberus://data/" + back
		If String.FromChar(top[0]) <> "/" And String.FromChar(top[1]) <> ":" Then top = "cerberus://data/" + top
		If String.FromChar(bottom[0]) <> "/" And String.FromChar(bottom[1]) <> ":" Then bottom = "cerberus://data/" + bottom
		
		Local texture:Int = glCreateTexture()
		glBindTexture(GL_TEXTURE_CUBE_MAP, texture)
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, MagFilter(filter))
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, MinFilter(filter, True))
		glTexImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, left)
		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, right)
		glTexImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, back)
		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, front)
		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, top)
		glTexImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, bottom)
'#If TARGET<>"html5"
		If filter > FILTER_LINEAR Then glGenerateMipmap(GL_TEXTURE_CUBE_MAP)
'#Endif
		'glBindTexture(GL_TEXTURE_2D, 0)

		Return texture
	End

	Function FreeTexture:Void(texture:Int)
		glDeleteTexture(texture)
	End

	Function SetTextures:Void(diffuseTex:Int, normalTex:Int, lightmap:Int, reflectionTex:Int, refractionTex:Int, isDiffuseCubic:Bool)
		If diffuseTex <> 0
			If Not isDiffuseCubic
				glActiveTexture(GL_TEXTURE0 + BASETEX_UNIT)
				glBindTexture(GL_TEXTURE_2D, diffuseTex)
			Else
				glActiveTexture(GL_TEXTURE0 + BASECUBE_UNIT)
				glBindTexture(GL_TEXTURE_CUBE_MAP, diffuseTex)
			End
		End
		If normalTex <> 0
			glActiveTexture(GL_TEXTURE0 + NORMALTEX_UNIT)
			glBindTexture(GL_TEXTURE_2D, normalTex)
		End
		If lightmap <> 0
			glActiveTexture(GL_TEXTURE0 + LIGHTMAP_UNIT)
			glBindTexture(GL_TEXTURE_2D, lightmap)
		End
		If reflectionTex <> 0
			glActiveTexture(GL_TEXTURE0 + REFLECTTEX_UNIT)
			glBindTexture(GL_TEXTURE_CUBE_MAP, reflectionTex)
		End
		If refractionTex <> 0
			glActiveTexture(GL_TEXTURE0 + REFRACTTEX_UNIT)
			glBindTexture(GL_TEXTURE_CUBE_MAP, refractionTex)
		End
		glActiveTexture(GL_TEXTURE0)
		
		If diffuseTex = 0
			mState.BaseTexMode = 0
		Elseif Not isDiffuseCubic
			mState.BaseTexMode = 1
		Else
			mState.BaseTexMode = 2
		End
		mState.UseNormalTex = normalTex <> 0
		mState.UseLightTex = lightmap <> 0
		mState.UseReflectTex = reflectionTex <> 0
		mState.UseRefractTex = refractionTex <> 0
	End
	
	Function SetTextureMatrix:Void(m:Mat4)
		mState.TextureMatrix.Set(m)
	End
	
	'---------------------------------------------------------------------------
	' Framebuffer
	'---------------------------------------------------------------------------
	
	Function CreateFramebuffer:Int(colorTex:Int, depthBuffer:Int)
		Local fb:Int = glCreateFramebuffer()
		SetFramebuffer(fb, mFramebufferHeight)
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorTex, 0)
		If depthBuffer <> 0 Then glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthBuffer)
		SetFramebuffer(0, mFramebufferHeight)
		Return fb
	End
	
	Function FreeFramebuffer:Void(fb:Int)
		glDeleteFramebuffer(fb)
	End
	
	Function SetFramebuffer:Void(fb:Int, height:Int)
		glBindFramebuffer(GL_FRAMEBUFFER, fb)
		If fb <> 0 Then mFramebufferHeight = height Else mFramebufferHeight = 0
	End
	
	'---------------------------------------------------------------------------
	'	Renderbuffer
	'---------------------------------------------------------------------------
	
	Function CreateRenderbuffer:Int(width:Int, height:Int)
		Local rb:Int = glCreateRenderbuffer()
		glBindRenderbuffer(GL_RENDERBUFFER, rb)
		glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height)
		glBindRenderbuffer(GL_RENDERBUFFER, 0)
		Return rb
	End
	
	Function FreeRenderbuffer:Void(rb:Int)
		glDeleteRenderbuffer(rb)
	End

	'---------------------------------------------------------------------------
	' VBO
	'---------------------------------------------------------------------------

	Function CreateVertexBuffer:Int(size:Int)
		Local buffer:Int = glCreateBuffer()
		If size > 0 Then ResizeVertexBuffer(buffer, size)
		Return buffer
	End
	
	Function CreateIndexBuffer:Int(size:Int)
		Local buffer:Int = glCreateBuffer()
		If size > 0 Then ResizeIndexBuffer(buffer, size)
		Return buffer
	End

	Function FreeBuffer:Void(buffer:Int)
		glDeleteBuffer(buffer)
	End
	
	Function ResizeVertexBuffer:Void(buffer:Int, size:Int)
		glBindBuffer(GL_ARRAY_BUFFER, buffer)
		glBufferData(GL_ARRAY_BUFFER, size, Null, GL_STATIC_DRAW)
		glBindBuffer(GL_ARRAY_BUFFER, 0)
	End
	
	Function ResizeIndexBuffer:Void(buffer:Int, size:Int)
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffer)
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, size, Null, GL_STATIC_DRAW)
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)
	End

	Function SetVertexBufferData:Void(buffer:Int, offset:Int, size:Int, data:DataBuffer)
		glBindBuffer(GL_ARRAY_BUFFER, buffer)
		glBufferSubData(GL_ARRAY_BUFFER, offset, size, data)
		glBindBuffer(GL_ARRAY_BUFFER, 0)
	End

	Function SetIndexBufferData:Void(buffer:Int, offset:Int, size:Int, data:DataBuffer)
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffer)
		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, offset, size, data)
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)
	End

	Function DrawBuffers:Void(vertexBuffer:Int, indexBuffer:Int, numIndices:Int, coordsOffset:Int, normalsOffset:Int, tangentsOffset:Int, colorsOffset:Int, texCoordsOffset:Int, texCoords2Offset:Int, boneIndicesOffset:Int, boneWeightsOffset:Int, stride:Int, mode:Int = -1)
		If mode = -1 Then mode = GL_TRIANGLES
		
		mActiveShader.Prepare()
		
		'Get currently bound buffers
		glGetIntegerv(GL_ARRAY_BUFFER_BINDING, mTempArray)
		Local prevVertexBuffer:Int = mTempArray[0]
		glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, mTempArray)
		Local prevIndexBuffer:Int = mTempArray[0]
		
		'Bind buffers and enable vertex vars
		glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer)
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer)
		mActiveShader.EnableVertexVars(coordsOffset, normalsOffset, tangentsOffset, colorsOffset, texCoordsOffset, texCoords2Offset, boneIndicesOffset, boneWeightsOffset, stride)

		'Draw
		If indexBuffer <> 0
			glDrawElements(mode, numIndices, GL_UNSIGNED_SHORT, 0)
		Else
			glDrawArrays(mode, 0, numIndices)
		End
		
		'Disable vertex vars
		mActiveShader.DisableVertexVars()
		
		'Bind previously bound buffers (in case they are the Mojo2 ones)
		glBindBuffer(GL_ARRAY_BUFFER, prevVertexBuffer)
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, prevIndexBuffer)
	End

	'---------------------------------------------------------------------------
	' Shaders
	'---------------------------------------------------------------------------
	
	Function CreateShader:Int(vertex:String, fragment:String)
		Local retCode:Int[1]

		'Create vertex shader
		Local vshader:Int = glCreateShader(GL_VERTEX_SHADER)
		glShaderSource(vshader, vertex)
		glCompileShader(vshader)
		mShaderError = glGetShaderInfoLog(vshader)
		glGetShaderiv(vshader, GL_COMPILE_STATUS, retCode)
		If retCode[0] = GL_FALSE
			glDeleteShader(vshader)
			Return 0
		End

		'Create fragment shader
		Local fshader:Int = glCreateShader(GL_FRAGMENT_SHADER)
		glShaderSource(fshader, fragment)
		glCompileShader(fshader)
		mShaderError += "~n" + glGetShaderInfoLog(fshader)
		glGetShaderiv(fshader, GL_COMPILE_STATUS, retCode)
		If retCode[0] = GL_FALSE
			glDeleteShader(vshader)
			glDeleteShader(fshader)
			Return 0
		End

		'Create program
		Local program:Int = glCreateProgram()
		glAttachShader(program, vshader)
		glAttachShader(program, fshader)
		glLinkProgram(program)
		glDeleteShader(vshader)
		glDeleteShader(fshader)
		glGetProgramiv(program, GL_LINK_STATUS, retCode)
		If retCode[0] = GL_FALSE
			mShaderError = glGetProgramInfoLog(program)
			FreeShader(program)
			Return 0
		End
		
		Return program
	End

	Function FreeShader:Void(shader:Int)
		glDeleteProgram(shader)
	End
	
	Function UseShader:Void(shader:Int)
		glUseProgram(shader)
	End
	
	Function ShaderLocation:Int(shader:Int, name:String)
		Return glGetUniformLocation(shader, name)
	End
	
	Function ShaderAttribLocation:Int(shader:Int, name:String)
		Return glGetAttribLocation(shader, name)
	End
	
	Function ShaderEnableAttrib:Void(loc:Int, size:Int, stride:Int, offset:Int)
		If loc = -1 Then Return
		glEnableVertexAttribArray(loc)
		glVertexAttribPointer(loc, size, GL_FLOAT, False, stride, offset)
	End
	
	Function ShaderDisableAttrib:Void(loc:Int)
		If loc = -1 Then Return
		glDisableVertexAttribArray(loc)
	End
	
	Function SetShaderInt:Void(loc:Int, x:Int)
		If loc = -1 Then Return
		glUniform1i(loc, x)
	End
	
	Function SetShaderFloat:Void(loc:Int, x:Float)
		If loc = -1 Then Return
		glUniform1f(loc, x)
	End
	
	Function SetShaderVec2:Void(loc:Int, x:Float, y:Float)
		If loc = -1 Then Return
		glUniform2f(loc, x, y)
	End
	
	Function SetShaderVec3:Void(loc:Int, x:Float, y:Float, z:Float)
		If loc = -1 Then Return
		glUniform3f(loc, x, y, z)
	End
	
	Function SetShaderVec4:Void(loc:Int, x:Float, y:Float, z:Float, w:Float)
		If loc = -1 Then Return
		glUniform4f(loc, x, y, z, w)
	End
	
	Function SetShaderMat4:Void(loc:Int, m:Mat4)
		If loc = -1 Then Return
		glUniformMatrix4fv(loc, 1, False, m.M)
	End

	Function ShaderError:String()
		Return mShaderError
	End
	
	Function VendorName:String()
		Return mVendor
	End
	
	Function RendererName:String()
		Return mRenderer
	End
	
	Function APIVersionName:String()
		Return mVersionStr
	End
	
	Function ShadingVersionName:String()
		Return mShadingVersionStr
	End

	Function APIVersion:Float()
		Return mVersion
	End Function

	Function ShadingVersion:Float()
		Return mShadingVersion
	End Function
	
	Function ErrorString:String()
		Local err:Int = glGetError()
		Select err
		Case GL_NO_ERROR
			Return "No error"
		Case GL_INVALID_ENUM
			Return "Invalid enum"
		Case GL_INVALID_VALUE
			Return "Invalid value"
		Case GL_INVALID_OPERATION
			Return "Invalid operation"
		Case GL_INVALID_FRAMEBUFFER_OPERATION
			Return "Invalid framebuffer operation"
		Case GL_OUT_OF_MEMORY
			Return "Out of memory"
		Default
			Return ""
		End
	End
	
	Function MaxTextureSize:Int()
		glGetIntegerv(GL_MAX_TEXTURE_SIZE, mTempArray)
		Return mTempArray[0]
	End
Private
	Method New()
	End

	Function MagFilter:Int(filtering:Int)
		Select filtering
		Case FILTER_NONE
			Return GL_NEAREST
		Case FILTER_LINEAR
			Return GL_LINEAR
		Case FILTER_BILINEAR
			Return GL_LINEAR
		Case FILTER_TRILINEAR
			Return GL_LINEAR
		Default
			Return GL_LINEAR
		End
	End

	Function MinFilter:Int(filtering:Int, isCubeMap:Bool = False)
		Select filtering
		Case FILTER_NONE
			Return GL_NEAREST
		Case FILTER_LINEAR
			Return GL_LINEAR
#If TARGET<>"html5"
		Case FILTER_BILINEAR
			Return GL_LINEAR_MIPMAP_NEAREST
		Case FILTER_TRILINEAR
			Return GL_LINEAR_MIPMAP_LINEAR
#Else
		Case FILTER_BILINEAR
			If Not isCubeMap Then Return GL_LINEAR_MIPMAP_NEAREST Else Return GL_LINEAR
		Case FILTER_TRILINEAR
			If Not isCubeMap Then Return GL_LINEAR_MIPMAP_LINEAR Else Return GL_LINEAR
#End
		Default
			Return GL_LINEAR
		End
	End
	
	Global mMaxLights	: Int
	Global mMaxBones	: Int

	'Info
	Global mVendor:String
	Global mRenderer:String
	Global mVersionStr:String
	Global mShadingVersionStr:String
	Global mVersion:Float
	Global mShadingVersion:Float

	Global mState:RendererState
	Global mEllipseBuffer:Int
	Global mLineBuffer:Int
	Global mRectBuffer:Int
	Global mFramebufferHeight:Int
	Global mTexDataBuffer:DataBuffer = New DataBuffer(32, True)
	Global mTempMatrix:Mat4 = Mat4.Create()
	Global mDefaultShader:Shader			'Default program id
	Global mDepthShader:Shader				'Depth program id
	Global m2DShader:Shader				'Default 2D program id
	Global mActiveShader:Shader			'Currently active program
	Global mShaderError:String					'Last error occured when compiling or linking a shader
	Global mTempArray:Int[1]					'Array used when requesting parameters to OpenGL
End
